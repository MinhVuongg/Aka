[
  {   "fm" : "vector< vector<string> > groupAnagrams(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             if (m.find(word)==m.end()){\r                 vector<string> v;\r                 v.push_back(strs[i]);\r                 result.push_back(v);\r                 m[word] = result.size()-1;\r                 \r             }else{\r                 result[m[word]].push_back(strs[i]);\r             }\r         }\r         \r         for(int i=0; i<result.size(); i++){\r             sort(result[i].begin(), result[i].end());\r         }\r         return result;\r     }",   "m" : [ ],   "fc" : "class Solution {\r public:\r     vector< vector<string> > groupAnagrams(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             if (m.find(word)==m.end()){\r                 vector<string> v;\r                 v.push_back(strs[i]);\r                 result.push_back(v);\r                 m[word] = result.size()-1;\r                 \r             }else{\r                 result[m[word]].push_back(strs[i]);\r             }\r         }\r         \r         for(int i=0; i<result.size(); i++){\r             sort(result[i].begin(), result[i].end());\r         }\r         return result;\r     }\r      \r     //using multiset \r     vector< vector<string> > groupAnagrams01(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, multiset<string>> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             m[word].insert(strs[i]);\r         }\r         \r         for(auto item : m){\r             vector<string> v(item.second.begin(), item.second.end());\r             result.push_back(v);\r         }\r         return result;\r     }\r \r \r     //NOTICE: the below solution has been depracated as the problem has been updated!\r     vector<string> anagrams(vector<string> &strs) {\r         vector<string> result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             //sort it can easy to check they are anagrams or not\r             sort(word.begin(), word.end());  \r             if (m.find(word)==m.end()){\r                 m[word] = i;\r             }else{\r                 if (m[word]>=0){\r                     result.push_back(strs[m[word]]);\r                     m[word]=-1;\r                 }\r                 result.push_back(strs[i]);\r             }\r         }\r         return result;\r     }\r };",   "c" : [ "", "" ],   "path_fm" : "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\anagrams\\GroupAnagrams.cpp\\Solution\\groupAnagrams(vector<string>&)",   "f" : [ ],   "t" : [ "void AKA_TEST_Solution_groupAnagrams_vector_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_groupAnagrams_vector_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\GroupAnagrams.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> strs;\nvector<vector<string>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode strs */\nchar* akaRandomName845088 = new char[2];akaRandomName845088[0] = 125;akaRandomName845088[1] = '\\0';string strs_element0=akaRandomName845088;\nstrs.push_back(strs_element0);\nchar* akaRandomName708370 = new char[2];akaRandomName708370[0] = -19;akaRandomName708370[1] = '\\0';string strs_element1=akaRandomName708370;\nstrs.push_back(strs_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_groupAnagrams_vector_string_random_2\");vector<vector<string>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->groupAnagrams(strs);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\anagrams\\\\GroupAnagrams.cpp\\\\Solution\\\\groupAnagrams(vector<string>&)\");\n\n\nvector<string> EXPECTED_strs;\n\n\n\n// tear down\n;\n}\n}\n", "void AKA_TEST_Solution_groupAnagrams_vector_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_groupAnagrams_vector_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\GroupAnagrams.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> strs;\nvector<vector<string>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode strs */\nchar* akaRandomName637302 = new char[2];akaRandomName637302[0] = 125;akaRandomName637302[1] = '\\0';string strs_element0=akaRandomName637302;\nstrs.push_back(strs_element0);\nchar* akaRandomName412838 = new char[2];akaRandomName412838[0] = -19;akaRandomName412838[1] = '\\0';string strs_element1=akaRandomName412838;\nstrs.push_back(strs_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_groupAnagrams_vector_string_random_2\");vector<vector<string>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->groupAnagrams(strs);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\anagrams\\\\GroupAnagrams.cpp\\\\Solution\\\\groupAnagrams(vector<string>&)\");\n\n\nvector<string> EXPECTED_strs;\n\n\n\n// tear down\n;\n}\n}\n" ] },
  {   "fm" : "vector< vector<string> > groupAnagrams01(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, multiset<string>> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             m[word].insert(strs[i]);\r         }\r         \r         for(auto item : m){\r             vector<string> v(item.second.begin(), item.second.end());\r             result.push_back(v);\r         }\r         return result;\r     }",   "m" : [ ],   "fc" : "class Solution {\r public:\r     vector< vector<string> > groupAnagrams(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             if (m.find(word)==m.end()){\r                 vector<string> v;\r                 v.push_back(strs[i]);\r                 result.push_back(v);\r                 m[word] = result.size()-1;\r                 \r             }else{\r                 result[m[word]].push_back(strs[i]);\r             }\r         }\r         \r         for(int i=0; i<result.size(); i++){\r             sort(result[i].begin(), result[i].end());\r         }\r         return result;\r     }\r      \r     //using multiset \r     vector< vector<string> > groupAnagrams01(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, multiset<string>> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             m[word].insert(strs[i]);\r         }\r         \r         for(auto item : m){\r             vector<string> v(item.second.begin(), item.second.end());\r             result.push_back(v);\r         }\r         return result;\r     }\r \r \r     //NOTICE: the below solution has been depracated as the problem has been updated!\r     vector<string> anagrams(vector<string> &strs) {\r         vector<string> result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             //sort it can easy to check they are anagrams or not\r             sort(word.begin(), word.end());  \r             if (m.find(word)==m.end()){\r                 m[word] = i;\r             }else{\r                 if (m[word]>=0){\r                     result.push_back(strs[m[word]]);\r                     m[word]=-1;\r                 }\r                 result.push_back(strs[i]);\r             }\r         }\r         return result;\r     }\r };",   "c" : [ "", "" ],   "path_fm" : "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\anagrams\\GroupAnagrams.cpp\\Solution\\groupAnagrams01(vector<string>&)",   "f" : [ ],   "t" : [ "void AKA_TEST_Solution_groupAnagrams01_vector_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_groupAnagrams01_vector_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\GroupAnagrams.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> strs;\nvector<vector<string>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode strs */\nchar* akaRandomName531566 = new char[2];akaRandomName531566[0] = 5;akaRandomName531566[1] = '\\0';string strs_element0=akaRandomName531566;\nstrs.push_back(strs_element0);\nchar* akaRandomName345274 = new char[2];akaRandomName345274[0] = 47;akaRandomName345274[1] = '\\0';string strs_element1=akaRandomName345274;\nstrs.push_back(strs_element1);\nchar* akaRandomName187003 = new char[2];akaRandomName187003[0] = 103;akaRandomName187003[1] = '\\0';string strs_element2=akaRandomName187003;\nstrs.push_back(strs_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_groupAnagrams01_vector_string_random_3\");vector<vector<string>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->groupAnagrams01(strs);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\anagrams\\\\GroupAnagrams.cpp\\\\Solution\\\\groupAnagrams01(vector<string>&)\");\n\n\nvector<string> EXPECTED_strs;\n\n\n\n// tear down\n;\n}\n}\n" ] },
  {   "fm" : "vector<string> anagrams(vector<string> &strs) {\r         vector<string> result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             //sort it can easy to check they are anagrams or not\r             sort(word.begin(), word.end());  \r             if (m.find(word)==m.end()){\r                 m[word] = i;\r             }else{\r                 if (m[word]>=0){\r                     result.push_back(strs[m[word]]);\r                     m[word]=-1;\r                 }\r                 result.push_back(strs[i]);\r             }\r         }\r         return result;\r     }",   "m" : [ ],   "fc" : "class Solution {\r public:\r     vector< vector<string> > groupAnagrams(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             if (m.find(word)==m.end()){\r                 vector<string> v;\r                 v.push_back(strs[i]);\r                 result.push_back(v);\r                 m[word] = result.size()-1;\r                 \r             }else{\r                 result[m[word]].push_back(strs[i]);\r             }\r         }\r         \r         for(int i=0; i<result.size(); i++){\r             sort(result[i].begin(), result[i].end());\r         }\r         return result;\r     }\r      \r     //using multiset \r     vector< vector<string> > groupAnagrams01(vector<string> &strs) {\r         vector< vector<string> > result;\r         map<string, multiset<string>> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             sort(word.begin(), word.end());\r             m[word].insert(strs[i]);\r         }\r         \r         for(auto item : m){\r             vector<string> v(item.second.begin(), item.second.end());\r             result.push_back(v);\r         }\r         return result;\r     }\r \r \r     //NOTICE: the below solution has been depracated as the problem has been updated!\r     vector<string> anagrams(vector<string> &strs) {\r         vector<string> result;\r         map<string, int> m;\r         for(int i=0; i<strs.size(); i++){\r             string word = strs[i];\r             //sort it can easy to check they are anagrams or not\r             sort(word.begin(), word.end());  \r             if (m.find(word)==m.end()){\r                 m[word] = i;\r             }else{\r                 if (m[word]>=0){\r                     result.push_back(strs[m[word]]);\r                     m[word]=-1;\r                 }\r                 result.push_back(strs[i]);\r             }\r         }\r         return result;\r     }\r };",   "c" : [ "", "" ],   "path_fm" : "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\anagrams\\GroupAnagrams.cpp\\Solution\\anagrams(vector<string>&)",   "f" : [ ],   "t" : [ "void AKA_TEST_Solution_anagrams_vector_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_anagrams_vector_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\GroupAnagrams.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> strs;\nvector<string> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode strs */\nchar* akaRandomName224894 = new char[2];akaRandomName224894[0] = -25;akaRandomName224894[1] = '\\0';string strs_element0=akaRandomName224894;\nstrs.push_back(strs_element0);\nchar* akaRandomName450202 = new char[2];akaRandomName450202[0] = 64;akaRandomName450202[1] = '\\0';string strs_element1=akaRandomName450202;\nstrs.push_back(strs_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_anagrams_vector_string_random_2\");vector<string> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->anagrams(strs);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\anagrams\\\\GroupAnagrams.cpp\\\\Solution\\\\anagrams(vector<string>&)\");\n\n\nvector<string> EXPECTED_strs;\n\n\n\n// tear down\n;\n}\n}\n" ] }
]
