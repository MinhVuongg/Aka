[
  {   "t" : [ "void AKA_TEST_linear_search1_long_long_long_random_3(void) {\n{\nAKA_test_case_name=\"linear_search1_long_long_long_random_3\";\n\n// set up\n;\n\nlong a[2];;\n\n\nlong n=5;\n\n\nlong find=-243044902;\n\n\nlong AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\na[0]=1555610589;\n/* NormalNumberDataNode a[1] */\na[1]=-2123849484;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode find */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test linear_search1_long_long_long_random_3\");long AKA_ACTUAL_OUTPUT=Algorithm::Search::linear_search1(a,n,find);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\linear_search1(long[],long,long)\");\n\n\n\n\n// tear down\n;\n}\n}\n", "void AKA_TEST_linear_search1_long_long_long_random_3(void) {\n{\nAKA_test_case_name=\"linear_search1_long_long_long_random_3\";\n\n// set up\n;\n\nlong a[2];;\n\n\nlong n=5;\n\n\nlong find=-243044902;\n\n\nlong AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\na[0]=1555610589;\n/* NormalNumberDataNode a[1] */\na[1]=-2123849484;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode find */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test linear_search1_long_long_long_random_3\");long AKA_ACTUAL_OUTPUT=Algorithm::Search::linear_search1(a,n,find);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\linear_search1(long[],long,long)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\linear_search1(long[],long,long)",   "c" : [ ],   "fc" : "",   "m" : [ ],   "fm" : "long linear_search1(long a[], long n, long find) {\r \tlong c;\r \r \tfor (c = 0; c < n; c++) {\r \t\tif (a[c] == find)\r \t\t\treturn c;\r \t}\r \r \treturn -1;\r }" },
  {   "t" : [ "void AKA_TEST_linear_search2_longmul_long_long_random_1(void) {\n{\nAKA_test_case_name=\"linear_search2_longmul_long_long_random_1\";\n\n// set up\n;\n\nlong AKA_ARRAY_INIT_pointer[1];\n\n\nlong AKA_ARRAY_INIT_pointer_0=389288122;\nAKA_ARRAY_INIT_pointer[0] = AKA_ARRAY_INIT_pointer_0;\n\nlong* pointer = AKA_ARRAY_INIT_pointer;\n\n\nlong n=8;\n\n\nlong find=-952697251;\n\n\nlong AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode pointer */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode find */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test linear_search2_longmul_long_long_random_1\");long AKA_ACTUAL_OUTPUT=Algorithm::Search::linear_search2(pointer,n,find);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\linear_search2(long*,long,long)\");\n\n\n\n\n// tear down\n;\n}\n}\n", "void AKA_TEST_linear_search2_longmul_long_long_random_1(void) {\n{\nAKA_test_case_name=\"linear_search2_longmul_long_long_random_1\";\n\n// set up\n;\n\nlong AKA_ARRAY_INIT_pointer[1];\n\n\nlong AKA_ARRAY_INIT_pointer_0=389288122;\nAKA_ARRAY_INIT_pointer[0] = AKA_ARRAY_INIT_pointer_0;\n\nlong* pointer = AKA_ARRAY_INIT_pointer;\n\n\nlong n=8;\n\n\nlong find=-952697251;\n\n\nlong AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode pointer */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode find */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test linear_search2_longmul_long_long_random_1\");long AKA_ACTUAL_OUTPUT=Algorithm::Search::linear_search2(pointer,n,find);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\linear_search2(long*,long,long)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\linear_search2(long*,long,long)",   "c" : [ ],   "fc" : "",   "m" : [ ],   "fm" : "long linear_search2(long *pointer, long n, long find) {\r \tlong c;\r \r \tfor (c = 0; c < n; c++) {\r \t\tif (*(pointer + c) == find)\r \t\t\treturn c;\r \t}\r \r \treturn -1;\r }" },
  {   "t" : [ "void AKA_TEST_binarySearch_int_int_int_int_random_1(void) {\n{\nAKA_test_case_name=\"binarySearch_int_int_int_int_random_1\";\n\n// set up\n;\n\nint arr[3];;\n\n\nint l=-1131179258;\n\n\nint r=-456405430;\n\n\nint x=1538791365;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=1302875958;\n/* NormalNumberDataNode arr[1] */\narr[1]=571177432;\n/* NormalNumberDataNode arr[2] */\narr[2]=-1653009281;\n/* NormalNumberDataNode l */\n/* NormalNumberDataNode r */\n/* NormalNumberDataNode x */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test binarySearch_int_int_int_int_random_1\");int AKA_ACTUAL_OUTPUT=Algorithm::Search::binarySearch(arr,l,r,x);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\binarySearch(int[],int,int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n", "void AKA_TEST_binarySearch_int_int_int_int_random_1(void) {\n{\nAKA_test_case_name=\"binarySearch_int_int_int_int_random_1\";\n\n// set up\n;\n\nint arr[3];;\n\n\nint l=-1131179258;\n\n\nint r=-456405430;\n\n\nint x=1538791365;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=1302875958;\n/* NormalNumberDataNode arr[1] */\narr[1]=571177432;\n/* NormalNumberDataNode arr[2] */\narr[2]=-1653009281;\n/* NormalNumberDataNode l */\n/* NormalNumberDataNode r */\n/* NormalNumberDataNode x */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test binarySearch_int_int_int_int_random_1\");int AKA_ACTUAL_OUTPUT=Algorithm::Search::binarySearch(arr,l,r,x);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\binarySearch(int[],int,int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\binarySearch(int[],int,int,int)",   "c" : [ ],   "fc" : "",   "m" : [ "int binarySearch(int arr[], int l, int r, int x) {\r\n\tif (r >= l) {\r\n\t\tint mid = l + (r - l) / 2;\r\n\r\n\t\t// If the element is present at the middle itself\r\n\t\tif (arr[mid] == x)\r\n\t\t\treturn mid;\r\n\r\n\t\t// If element is smaller than mid, then it can only be present\r\n\t\t// in left subarray\r\n\t\tif (arr[mid] > x)\r\n\t\t\treturn binarySearch(arr, l, mid - 1, x);\r\n\r\n\t\t// Else the element can only be present in right subarray\r\n\t\treturn binarySearch(arr, mid + 1, r, x);\r\n\t}\r\n\r\n\t// We reach here when element is not present in array\r\n\treturn -1;\r\n}", "int binarySearch(int arr[], int l, int r, int x) {\r\n\tif (r >= l) {\r\n\t\tint mid = l + (r - l) / 2;\r\n\r\n\t\t// If the element is present at the middle itself\r\n\t\tif (arr[mid] == x)\r\n\t\t\treturn mid;\r\n\r\n\t\t// If element is smaller than mid, then it can only be present\r\n\t\t// in left subarray\r\n\t\tif (arr[mid] > x)\r\n\t\t\treturn binarySearch(arr, l, mid - 1, x);\r\n\r\n\t\t// Else the element can only be present in right subarray\r\n\t\treturn binarySearch(arr, mid + 1, r, x);\r\n\t}\r\n\r\n\t// We reach here when element is not present in array\r\n\treturn -1;\r\n}" ],   "fm" : "int binarySearch(int arr[], int l, int r, int x) {\r \tif (r >= l) {\r \t\tint mid = l + (r - l) / 2;\r \r \t\t// If the element is present at the middle itself\r \t\tif (arr[mid] == x)\r \t\t\treturn mid;\r \r \t\t// If element is smaller than mid, then it can only be present\r \t\t// in left subarray\r \t\tif (arr[mid] > x)\r \t\t\treturn binarySearch(arr, l, mid - 1, x);\r \r \t\t// Else the element can only be present in right subarray\r \t\treturn binarySearch(arr, mid + 1, r, x);\r \t}\r \r \t// We reach here when element is not present in array\r \treturn -1;\r }" },
  {   "t" : [ "void AKA_TEST_NaivePatternSearch_charmul_charmul_random_0(void) {\n{\nAKA_test_case_name=\"NaivePatternSearch_charmul_charmul_random_0\";\n\n// set up\n;\n\nchar AKA_ARRAY_INIT_pat[2];\n\nchar AKA_ARRAY_INIT_pat_0=-17;\nAKA_ARRAY_INIT_pat[0] = AKA_ARRAY_INIT_pat_0;\n\nchar AKA_ARRAY_INIT_pat_1=0;\nAKA_ARRAY_INIT_pat[1] = AKA_ARRAY_INIT_pat_1;\n\nchar* pat = AKA_ARRAY_INIT_pat;\nchar AKA_ARRAY_INIT_txt[2];\n\nchar AKA_ARRAY_INIT_txt_0=-105;\nAKA_ARRAY_INIT_txt[0] = AKA_ARRAY_INIT_txt_0;\n\nchar AKA_ARRAY_INIT_txt_1=-114;\nAKA_ARRAY_INIT_txt[1] = AKA_ARRAY_INIT_txt_1;\n\nchar* txt = AKA_ARRAY_INIT_txt;\n\n/* RootDataNode STATIC */\n/* PointerCharacterDataNode pat */\n/* PointerCharacterDataNode txt */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test NaivePatternSearch_charmul_charmul_random_0\");Algorithm::Search::NaivePatternSearch(pat,txt);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\NaivePatternSearch(char*,char*)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\NaivePatternSearch(char*,char*)",   "c" : [ ],   "fc" : "",   "m" : [ ],   "fm" : "void NaivePatternSearch(char *pat, char *txt) {\r \tint M = strlen(pat);\r \tint N = strlen(txt);\r \r \t/* A loop to slide pat[] one by one */\r \tfor (int i = 0; i <= N - M; i++) {\r \t\tint j;\r \r \t\t/* For current index i, check for pattern match */\r \t\tfor (j = 0; j < M; j++)\r \t\t\tif (txt[i + j] != pat[j])\r \t\t\t\tbreak;\r \r \t\tif (j == M)  // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\r \t\t\tprintf(\"Pattern found at index %d n\", i);\r \t}\r }" },
  {   "t" : [ "void AKA_TEST_computeLPSArray_charmul_int_intmul_random_2(void) {\n{\nAKA_test_case_name=\"computeLPSArray_charmul_int_intmul_random_2\";\n\n// set up\n;\n\nchar AKA_ARRAY_INIT_pat[2];\n\nchar AKA_ARRAY_INIT_pat_0=-30;\nAKA_ARRAY_INIT_pat[0] = AKA_ARRAY_INIT_pat_0;\n\nchar AKA_ARRAY_INIT_pat_1=64;\nAKA_ARRAY_INIT_pat[1] = AKA_ARRAY_INIT_pat_1;\n\nchar* pat = AKA_ARRAY_INIT_pat;\n\n\nint M=8;\nint AKA_ARRAY_INIT_lps[3];\n\n\nint AKA_ARRAY_INIT_lps_0=-815201346;\nAKA_ARRAY_INIT_lps[0] = AKA_ARRAY_INIT_lps_0;\n\n\nint AKA_ARRAY_INIT_lps_1=1373213011;\nAKA_ARRAY_INIT_lps[1] = AKA_ARRAY_INIT_lps_1;\n\n\nint AKA_ARRAY_INIT_lps_2=-186281533;\nAKA_ARRAY_INIT_lps[2] = AKA_ARRAY_INIT_lps_2;\n\nint* lps = AKA_ARRAY_INIT_lps;\n\n/* RootDataNode STATIC */\n/* PointerCharacterDataNode pat */\n/* NormalNumberDataNode M */\n/* PointerNumberDataNode lps */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test computeLPSArray_charmul_int_intmul_random_2\");Algorithm::Search::computeLPSArray(pat,M,lps);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\computeLPSArray(char*,int,int*)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\computeLPSArray(char*,int,int*)",   "c" : [ ],   "fc" : "",   "m" : [ "void KMPSearch(char *pat, char *txt) {\r\n\tint M = strlen(pat);\r\n\tint N = strlen(txt);\r\n\r\n\t// create lps[] that will hold the longest prefix suffix\r\n\t// values for pattern\r\n\tint lps[M];\r\n\r\n\t// Preprocess the pattern (calculate lps[] array)\r\n\tcomputeLPSArray(pat, M, lps);\r\n\r\n\tint i = 0;\t\t// index for txt[]\r\n\tint j = 0;\t\t// index for pat[]\r\n\twhile (i < N) {\r\n\t\tif (pat[j] == txt[i]) {\r\n\t\t\tj++;\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tif (j == M) {\r\n\t\t\tprintf(\"Found pattern at index %d n\", i - j);\r\n\t\t\tj = lps[j - 1];\r\n\t\t}\r\n\r\n\t\t// mismatch after j matches\r\n\t\telse if (i < N && pat[j] != txt[i]) {\r\n\t\t\t// Do not match lps[0..lps[j-1]] characters,\r\n\t\t\t// they will match anyway\r\n\t\t\tif (j != 0)\r\n\t\t\t\tj = lps[j - 1];\r\n\t\t\telse\r\n\t\t\t\ti = i + 1;\r\n\t\t}\r\n\t}\r\n}" ],   "fm" : "void computeLPSArray(char *pat, int M, int *lps) {\r \t// length of the previous longest prefix suffix\r \tint len = 0;\r \r \tlps[0] = 0;  // lps[0] is always 0\r \r \t// the loop calculates lps[i] for i = 1 to M-1\r \tint i = 1;\r \twhile (i < M) {\r \t\tif (pat[i] == pat[len]) {\r \t\t\tlen++;\r \t\t\tlps[i] = len;\r \t\t\ti++;\r \t\t} else { // (pat[i] != pat[len])\r \t\t\t// This is tricky. Consider the example.\r \t\t\t// AAACAAAA and i = 7. The idea is similar\r \t\t\t// to search step.\r \t\t\tif (len != 0) {\r \t\t\t\tlen = lps[len - 1];\r \r \t\t\t\t// Also, note that we do not increment\r \t\t\t\t// i here\r \t\t\t} else { // if (len == 0)\r \t\t\t\tlps[i] = 0;\r \t\t\t\ti++;\r \t\t\t}\r \t\t}\r \t}\r }" },
  {   "t" : [ "void AKA_TEST_KMPSearch_charmul_charmul_random_4(void) {\n{\nAKA_test_case_name=\"KMPSearch_charmul_charmul_random_4\";\n\n// set up\n;\n\nchar AKA_ARRAY_INIT_pat[2];\n\nchar AKA_ARRAY_INIT_pat_0=58;\nAKA_ARRAY_INIT_pat[0] = AKA_ARRAY_INIT_pat_0;\n\nchar AKA_ARRAY_INIT_pat_1=91;\nAKA_ARRAY_INIT_pat[1] = AKA_ARRAY_INIT_pat_1;\n\nchar* pat = AKA_ARRAY_INIT_pat;\nchar AKA_ARRAY_INIT_txt[2];\n\nchar AKA_ARRAY_INIT_txt_0=12;\nAKA_ARRAY_INIT_txt[0] = AKA_ARRAY_INIT_txt_0;\n\nchar AKA_ARRAY_INIT_txt_1=62;\nAKA_ARRAY_INIT_txt[1] = AKA_ARRAY_INIT_txt_1;\n\nchar* txt = AKA_ARRAY_INIT_txt;\n\n/* RootDataNode STATIC */\n/* PointerCharacterDataNode pat */\n/* PointerCharacterDataNode txt */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test KMPSearch_charmul_charmul_random_4\");Algorithm::Search::KMPSearch(pat,txt);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Search.cpp\\\\Algorithm\\\\Search\\\\KMPSearch(char*,char*)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Search.cpp\\Algorithm\\Search\\KMPSearch(char*,char*)",   "c" : [ ],   "fc" : "",   "m" : [ "int main() {\r\n \tchar *txt = \"ABABDABACDABABCABAB\";\r\n \tchar *pat = \"ABABCABAB\"; if (1) txt = \"ABCD\";\r\n \tAlgorithm::Search::KMPSearch(pat, txt);\r\n \treturn 0;\r\n}", "void computeLPSArray(char *pat, int M, int *lps) {\r\n\t// length of the previous longest prefix suffix\r\n\tint len = 0;\r\n\r\n\tlps[0] = 0;  // lps[0] is always 0\r\n\r\n\t// the loop calculates lps[i] for i = 1 to M-1\r\n\tint i = 1;\r\n\twhile (i < M) {\r\n\t\tif (pat[i] == pat[len]) {\r\n\t\t\tlen++;\r\n\t\t\tlps[i] = len;\r\n\t\t\ti++;\r\n\t\t} else { // (pat[i] != pat[len])\r\n\t\t\t// This is tricky. Consider the example.\r\n\t\t\t// AAACAAAA and i = 7. The idea is similar\r\n\t\t\t// to search step.\r\n\t\t\tif (len != 0) {\r\n\t\t\t\tlen = lps[len - 1];\r\n\r\n\t\t\t\t// Also, note that we do not increment\r\n\t\t\t\t// i here\r\n\t\t\t} else { // if (len == 0)\r\n\t\t\t\tlps[i] = 0;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}" ],   "fm" : "void KMPSearch(char *pat, char *txt) {\r \tint M = strlen(pat);\r \tint N = strlen(txt);\r \r \t// create lps[] that will hold the longest prefix suffix\r \t// values for pattern\r \tint lps[M];\r \r \t// Preprocess the pattern (calculate lps[] array)\r \tcomputeLPSArray(pat, M, lps);\r \r \tint i = 0;\t\t// index for txt[]\r \tint j = 0;\t\t// index for pat[]\r \twhile (i < N) {\r \t\tif (pat[j] == txt[i]) {\r \t\t\tj++;\r \t\t\ti++;\r \t\t}\r \r \t\tif (j == M) {\r \t\t\tprintf(\"Found pattern at index %d n\", i - j);\r \t\t\tj = lps[j - 1];\r \t\t}\r \r \t\t// mismatch after j matches\r \t\telse if (i < N && pat[j] != txt[i]) {\r \t\t\t// Do not match lps[0..lps[j-1]] characters,\r \t\t\t// they will match anyway\r \t\t\tif (j != 0)\r \t\t\t\tj = lps[j - 1];\r \t\t\telse\r \t\t\t\ti = i + 1;\r \t\t}\r \t}\r }" }
]
