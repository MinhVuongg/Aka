[
  {   "fm" : "TreeNode *sortedListToBST(ListNode *head) {\r     if (NULL == head) {\r       return NULL;\r     }\r \r     ListNode *curr = head;\r     ListNode *next = head;\r     ListNode *prev = NULL;\r \r     while (next != NULL) {\r       // 通过走一步／两步找到中间节点\r       next = next->next;\r \r       if (NULL == next) {\r         break;\r       }\r \r       next = next->next;\r       prev = curr;\r       curr = curr->next;\r     }\r \r     if (NULL == curr) {\r       return new TreeNode(head->val);\r     }\r     else {\r       TreeNode *root = new TreeNode(curr->val);\r \r       // 把链表拆成两端递归\r       if (prev != NULL) {\r         prev->next = NULL;\r         root->left = sortedListToBST(head);\r       }\r \r       root->right = sortedListToBST(curr->next);\r \r       return root;\r     }\r   }",   "f" : [ ],   "t" : [ "void AKA_TEST_Solution_sortedListToBST_ListNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_sortedListToBST_ListNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-2036891136;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0).val=1902764445;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=-1854175100;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_1).val=323205353;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=1237297207;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_2).val=1436525904;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nTreeNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_sortedListToBST_ListNodemul_random_0\");TreeNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->sortedListToBST(head);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\Solution\\\\sortedListToBST(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "c" : [ "" ],   "path_fm" : "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-10\\convert_sorted_list_to_binary_search_tree.cpp\\Solution\\sortedListToBST(ListNode*)",   "simplified_t" : [ "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-2036891136;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0).val=1902764445;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=-1854175100;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_1).val=323205353;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=1237297207;\nAKA_mark(\"Calling: .\\\\com-10\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\convert_sorted_list_to_binary_search_tree.cpp\\\\sortedListToBST(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_2).val=1436525904;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nTreeNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n" ],   "m" : [ "TreeNode *sortedListToBST(ListNode *head) {\r\n    if (NULL == head) {\r\n      return NULL;\r\n    }\r\n\r\n    ListNode *curr = head;\r\n    ListNode *next = head;\r\n    ListNode *prev = NULL;\r\n\r\n    while (next != NULL) {\r\n      // 通过走一步／两步找到中间节点\r\n      next = next->next;\r\n\r\n      if (NULL == next) {\r\n        break;\r\n      }\r\n\r\n      next = next->next;\r\n      prev = curr;\r\n      curr = curr->next;\r\n    }\r\n\r\n    if (NULL == curr) {\r\n      return new TreeNode(head->val);\r\n    }\r\n    else {\r\n      TreeNode *root = new TreeNode(curr->val);\r\n\r\n      // 把链表拆成两端递归\r\n      if (prev != NULL) {\r\n        prev->next = NULL;\r\n        root->left = sortedListToBST(head);\r\n      }\r\n\r\n      root->right = sortedListToBST(curr->next);\r\n\r\n      return root;\r\n    }\r\n  }", "TreeNode *sortedListToBST(ListNode *head) {\r\n    if (NULL == head) {\r\n      return NULL;\r\n    }\r\n\r\n    ListNode *curr = head;\r\n    ListNode *next = head;\r\n    ListNode *prev = NULL;\r\n\r\n    while (next != NULL) {\r\n      // 通过走一步／两步找到中间节点\r\n      next = next->next;\r\n\r\n      if (NULL == next) {\r\n        break;\r\n      }\r\n\r\n      next = next->next;\r\n      prev = curr;\r\n      curr = curr->next;\r\n    }\r\n\r\n    if (NULL == curr) {\r\n      return new TreeNode(head->val);\r\n    }\r\n    else {\r\n      TreeNode *root = new TreeNode(curr->val);\r\n\r\n      // 把链表拆成两端递归\r\n      if (prev != NULL) {\r\n        prev->next = NULL;\r\n        root->left = sortedListToBST(head);\r\n      }\r\n\r\n      root->right = sortedListToBST(curr->next);\r\n\r\n      return root;\r\n    }\r\n  }", "TreeNode *sortedListToBST(ListNode *head) {\r\n    if (NULL == head) {\r\n      return NULL;\r\n    }\r\n\r\n    ListNode *curr = head;\r\n    ListNode *next = head;\r\n    ListNode *prev = NULL;\r\n\r\n    while (next != NULL) {\r\n      // 通过走一步／两步找到中间节点\r\n      next = next->next;\r\n\r\n      if (NULL == next) {\r\n        break;\r\n      }\r\n\r\n      next = next->next;\r\n      prev = curr;\r\n      curr = curr->next;\r\n    }\r\n\r\n    if (NULL == curr) {\r\n      return new TreeNode(head->val);\r\n    }\r\n    else {\r\n      TreeNode *root = new TreeNode(curr->val);\r\n\r\n      // 把链表拆成两端递归\r\n      if (prev != NULL) {\r\n        prev->next = NULL;\r\n        root->left = sortedListToBST(head);\r\n      }\r\n\r\n      root->right = sortedListToBST(curr->next);\r\n\r\n      return root;\r\n    }\r\n  }" ],   "fc" : "class Solution {\r public:\r   TreeNode *sortedListToBST(ListNode *head) {\r     if (NULL == head) {\r       return NULL;\r     }\r \r     ListNode *curr = head;\r     ListNode *next = head;\r     ListNode *prev = NULL;\r \r     while (next != NULL) {\r       // 通过走一步／两步找到中间节点\r       next = next->next;\r \r       if (NULL == next) {\r         break;\r       }\r \r       next = next->next;\r       prev = curr;\r       curr = curr->next;\r     }\r \r     if (NULL == curr) {\r       return new TreeNode(head->val);\r     }\r     else {\r       TreeNode *root = new TreeNode(curr->val);\r \r       // 把链表拆成两端递归\r       if (prev != NULL) {\r         prev->next = NULL;\r         root->left = sortedListToBST(head);\r       }\r \r       root->right = sortedListToBST(curr->next);\r \r       return root;\r     }\r   }\r };" }
]
