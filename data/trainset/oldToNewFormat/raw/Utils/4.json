[
  {
    "fm": "int climbStairs(int n) {\r        if (n<=3) return n;\r        int a[2]={2,3};\r        for(int i=4; i<=n; i++){\r            int t = a[0] + a[1];\r            a[0] = a[1];\r            a[1] = t;\r        }\r        return a[1];\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\climbStairs\\climbStairs.cpp\\Solution\\climbStairs(int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     \r     int climbStairs(int n) {\r        if (n<=3) return n;\r        int a[2]={2,3};\r        for(int i=4; i<=n; i++){\r            int t = a[0] + a[1];\r            a[0] = a[1];\r            a[1] = t;\r        }\r        return a[1];\r     }\r     //Time too long\r     int climbStairs2(int n) {\r         if (n<=3) return n;\r         return climbStairs(n-1) + climbStairs(n-2);\r     }\r };",
    "m": [
      "int climbStairs2(int n) {\r\n        if (n<=3) return n;\r\n        return climbStairs(n-1) + climbStairs(n-2);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_climbStairs_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\climbStairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=9;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\climbStairs\\\\climbStairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_climbStairs_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\climbStairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=9;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\climbStairs\\\\climbStairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int climbStairs2(int n) {\r         if (n<=3) return n;\r         return climbStairs(n-1) + climbStairs(n-2);\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\climbStairs\\climbStairs.cpp\\Solution\\climbStairs2(int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     \r     int climbStairs(int n) {\r        if (n<=3) return n;\r        int a[2]={2,3};\r        for(int i=4; i<=n; i++){\r            int t = a[0] + a[1];\r            a[0] = a[1];\r            a[1] = t;\r        }\r        return a[1];\r     }\r     //Time too long\r     int climbStairs2(int n) {\r         if (n<=3) return n;\r         return climbStairs(n-1) + climbStairs(n-2);\r     }\r };",
    "m": [
      "int climbStairs(int n) {\r\n       if (n<=3) return n;\r\n       int a[2]={2,3};\r\n       for(int i=4; i<=n; i++){\r\n           int t = a[0] + a[1];\r\n           a[0] = a[1];\r\n           a[1] = t;\r\n       }\r\n       return a[1];\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_climbStairs2_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs2_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\climbStairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1666997024;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs2_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs2(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\climbStairs\\\\climbStairs.cpp\\\\Solution\\\\climbStairs2(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int abs_min (int x, int y, int z) {\r         return  abs_min(x, abs_min(y, z));\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestDessertCost\\ClosestDessertCost.cpp\\Solution\\abs_min(int,int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private:\r     int abs_min (int x, int y, int z) {\r         return  abs_min(x, abs_min(y, z));\r     }\r     // compare the absolute value and return the min one\r     // if their absolute value are equal, return the positive one.\r     int abs_min(int x, int y) {\r         int ax = abs(x);\r         int ay = abs(y);\r         if (ax == ay) return max(x, y);\r         return ax < ay ? x : y;\r     }\r public:\r     int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r \r         int min_gap = INT_MAX;\r         for (auto& base : baseCosts) {\r             int gap = closetToppingCost(toppingCosts, target - base, 0);\r             min_gap = abs_min(min_gap, gap);\r         }\r         \r         return target - min_gap;\r     }\r     \r     int closetToppingCost(vector<int>& costs, int target, int idx ){\r     \r         if (idx >= costs.size()) return target;\r \r         // three options: not slect, select once & select twice\r         int select_none  = closetToppingCost(costs, target, idx+1);\r         int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r         int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r         \r         return abs_min(select_none, select_once, select_twice);\r     }\r     \r };",
    "m": [
      "int abs_min(int x, int y) {\r\n        int ax = abs(x);\r\n        int ay = abs(y);\r\n        if (ax == ay) return max(x, y);\r\n        return ax < ay ? x : y;\r\n    }",
      "int closetToppingCost(vector<int>& costs, int target, int idx ){\r\n    \r\n        if (idx >= costs.size()) return target;\r\n\r\n        // three options: not slect, select once & select twice\r\n        int select_none  = closetToppingCost(costs, target, idx+1);\r\n        int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r\n        int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r\n        \r\n        return abs_min(select_none, select_once, select_twice);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_abs_min_int_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_abs_min_int_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestDessertCost.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint x=-1137198100;\n\n\nint y=-858464856;\n\n\nint z=890779558;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode x */\n/* NormalNumberDataNode y */\n/* NormalNumberDataNode z */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_abs_min_int_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->abs_min(x,y,z);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestDessertCost\\\\ClosestDessertCost.cpp\\\\Solution\\\\abs_min(int,int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int abs_min(int x, int y) {\r         int ax = abs(x);\r         int ay = abs(y);\r         if (ax == ay) return max(x, y);\r         return ax < ay ? x : y;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestDessertCost\\ClosestDessertCost.cpp\\Solution\\abs_min(int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private:\r     int abs_min (int x, int y, int z) {\r         return  abs_min(x, abs_min(y, z));\r     }\r     // compare the absolute value and return the min one\r     // if their absolute value are equal, return the positive one.\r     int abs_min(int x, int y) {\r         int ax = abs(x);\r         int ay = abs(y);\r         if (ax == ay) return max(x, y);\r         return ax < ay ? x : y;\r     }\r public:\r     int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r \r         int min_gap = INT_MAX;\r         for (auto& base : baseCosts) {\r             int gap = closetToppingCost(toppingCosts, target - base, 0);\r             min_gap = abs_min(min_gap, gap);\r         }\r         \r         return target - min_gap;\r     }\r     \r     int closetToppingCost(vector<int>& costs, int target, int idx ){\r     \r         if (idx >= costs.size()) return target;\r \r         // three options: not slect, select once & select twice\r         int select_none  = closetToppingCost(costs, target, idx+1);\r         int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r         int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r         \r         return abs_min(select_none, select_once, select_twice);\r     }\r     \r };",
    "m": [
      "int abs_min (int x, int y, int z) {\r\n        return  abs_min(x, abs_min(y, z));\r\n    }",
      "int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r\n\r\n        int min_gap = INT_MAX;\r\n        for (auto& base : baseCosts) {\r\n            int gap = closetToppingCost(toppingCosts, target - base, 0);\r\n            min_gap = abs_min(min_gap, gap);\r\n        }\r\n        \r\n        return target - min_gap;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_abs_min_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_abs_min_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestDessertCost.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint x=651751951;\n\n\nint y=2072724094;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode x */\n/* NormalNumberDataNode y */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_abs_min_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->abs_min(x,y);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestDessertCost\\\\ClosestDessertCost.cpp\\\\Solution\\\\abs_min(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r \r         int min_gap = INT_MAX;\r         for (auto& base : baseCosts) {\r             int gap = closetToppingCost(toppingCosts, target - base, 0);\r             min_gap = abs_min(min_gap, gap);\r         }\r         \r         return target - min_gap;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestDessertCost\\ClosestDessertCost.cpp\\Solution\\closestCost(vector<int>&,vector<int>&,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private:\r     int abs_min (int x, int y, int z) {\r         return  abs_min(x, abs_min(y, z));\r     }\r     // compare the absolute value and return the min one\r     // if their absolute value are equal, return the positive one.\r     int abs_min(int x, int y) {\r         int ax = abs(x);\r         int ay = abs(y);\r         if (ax == ay) return max(x, y);\r         return ax < ay ? x : y;\r     }\r public:\r     int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r \r         int min_gap = INT_MAX;\r         for (auto& base : baseCosts) {\r             int gap = closetToppingCost(toppingCosts, target - base, 0);\r             min_gap = abs_min(min_gap, gap);\r         }\r         \r         return target - min_gap;\r     }\r     \r     int closetToppingCost(vector<int>& costs, int target, int idx ){\r     \r         if (idx >= costs.size()) return target;\r \r         // three options: not slect, select once & select twice\r         int select_none  = closetToppingCost(costs, target, idx+1);\r         int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r         int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r         \r         return abs_min(select_none, select_once, select_twice);\r     }\r     \r };",
    "m": [
      "int closetToppingCost(vector<int>& costs, int target, int idx ){\r\n    \r\n        if (idx >= costs.size()) return target;\r\n\r\n        // three options: not slect, select once & select twice\r\n        int select_none  = closetToppingCost(costs, target, idx+1);\r\n        int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r\n        int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r\n        \r\n        return abs_min(select_none, select_once, select_twice);\r\n    }",
      "int abs_min(int x, int y) {\r\n        int ax = abs(x);\r\n        int ay = abs(y);\r\n        if (ax == ay) return max(x, y);\r\n        return ax < ay ? x : y;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_closestCost_vector_int_vector_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_closestCost_vector_int_vector_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestDessertCost.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> baseCosts;\nvector<int> toppingCosts;\n\n\nint target=-480273005;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode baseCosts */\nint baseCosts_element0=861523559;\nbaseCosts.push_back(baseCosts_element0);\nint baseCosts_element1=-109141621;\nbaseCosts.push_back(baseCosts_element1);\n/* VectorDataNode toppingCosts */\nint toppingCosts_element0=-1812648113;\ntoppingCosts.push_back(toppingCosts_element0);\nint toppingCosts_element1=-1301327235;\ntoppingCosts.push_back(toppingCosts_element1);\n/* NormalNumberDataNode target */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_closestCost_vector_int_vector_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->closestCost(baseCosts,toppingCosts,target);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestDessertCost\\\\ClosestDessertCost.cpp\\\\Solution\\\\closestCost(vector<int>&,vector<int>&,int)\");\n\n\nvector<int> EXPECTED_baseCosts;\n\nvector<int> EXPECTED_toppingCosts;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int closetToppingCost(vector<int>& costs, int target, int idx ){\r     \r         if (idx >= costs.size()) return target;\r \r         // three options: not slect, select once & select twice\r         int select_none  = closetToppingCost(costs, target, idx+1);\r         int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r         int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r         \r         return abs_min(select_none, select_once, select_twice);\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestDessertCost\\ClosestDessertCost.cpp\\Solution\\closetToppingCost(vector<int>&,int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private:\r     int abs_min (int x, int y, int z) {\r         return  abs_min(x, abs_min(y, z));\r     }\r     // compare the absolute value and return the min one\r     // if their absolute value are equal, return the positive one.\r     int abs_min(int x, int y) {\r         int ax = abs(x);\r         int ay = abs(y);\r         if (ax == ay) return max(x, y);\r         return ax < ay ? x : y;\r     }\r public:\r     int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r \r         int min_gap = INT_MAX;\r         for (auto& base : baseCosts) {\r             int gap = closetToppingCost(toppingCosts, target - base, 0);\r             min_gap = abs_min(min_gap, gap);\r         }\r         \r         return target - min_gap;\r     }\r     \r     int closetToppingCost(vector<int>& costs, int target, int idx ){\r     \r         if (idx >= costs.size()) return target;\r \r         // three options: not slect, select once & select twice\r         int select_none  = closetToppingCost(costs, target, idx+1);\r         int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r         int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r         \r         return abs_min(select_none, select_once, select_twice);\r     }\r     \r };",
    "m": [
      "int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\r\n\r\n        int min_gap = INT_MAX;\r\n        for (auto& base : baseCosts) {\r\n            int gap = closetToppingCost(toppingCosts, target - base, 0);\r\n            min_gap = abs_min(min_gap, gap);\r\n        }\r\n        \r\n        return target - min_gap;\r\n    }",
      "int closetToppingCost(vector<int>& costs, int target, int idx ){\r\n    \r\n        if (idx >= costs.size()) return target;\r\n\r\n        // three options: not slect, select once & select twice\r\n        int select_none  = closetToppingCost(costs, target, idx+1);\r\n        int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r\n        int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r\n        \r\n        return abs_min(select_none, select_once, select_twice);\r\n    }",
      "int closetToppingCost(vector<int>& costs, int target, int idx ){\r\n    \r\n        if (idx >= costs.size()) return target;\r\n\r\n        // three options: not slect, select once & select twice\r\n        int select_none  = closetToppingCost(costs, target, idx+1);\r\n        int select_once  = closetToppingCost(costs, target - costs[idx], idx+1);\r\n        int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);\r\n        \r\n        return abs_min(select_none, select_once, select_twice);\r\n    }",
      "int abs_min (int x, int y, int z) {\r\n        return  abs_min(x, abs_min(y, z));\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_closetToppingCost_vector_int_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_closetToppingCost_vector_int_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestDessertCost.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> costs;\n\n\nint target=-1295530857;\n\n\nint idx=1707581507;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode costs */\nint costs_element0=573464047;\ncosts.push_back(costs_element0);\nint costs_element1=724410652;\ncosts.push_back(costs_element1);\n/* NormalNumberDataNode target */\n/* NormalNumberDataNode idx */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_closetToppingCost_vector_int_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->closetToppingCost(costs,target,idx);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestDessertCost\\\\ClosestDessertCost.cpp\\\\Solution\\\\closetToppingCost(vector<int>&,int,int)\");\n\n\nvector<int> EXPECTED_costs;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {\r         \r \r         for(int i=0; i<queries.size(); i++) { \r             queries[i].push_back(i);\r         }\r         \r         // sorted the rooms by size by descending order, because query the minimal size.\r         auto sort_by_size_desc =  [&](vector<int>& lhs, vector<int>&rhs) {\r             if (lhs[1] != rhs[1] ) return lhs[1] > rhs[1];\r             return lhs[0] < rhs[0];\r         };\r         sort(rooms.begin(), rooms.end(), sort_by_size_desc);\r         sort(queries.begin(), queries.end(), sort_by_size_desc);\r         //print(rooms);\r         //print(queries);\r         \r         vector<int> result(queries.size(), -1);\r         set<int> ids;\r         int i = 0;\r         for( auto& q: queries) {\r             int preferId = q[0];\r             int minSize = q[1];\r             int idx = q[2];\r             for (;i < rooms.size() && rooms[i][1] >= minSize; i++) {\r                 ids.insert(rooms[i][0]);\r             }\r             if (ids.size() <= 0 ) continue;\r             auto it = ids.lower_bound(preferId); \r             \r             int id1 = (it == ids.begin() ? -1 : *(prev(it)));\r             int id2 = (it == ids.end() ? -1 : *it);\r             \r             if (id1 == -1 || id2 == -1) {\r                 result[idx] = max(id1, id2);\r             }else{\r                 result[idx] = abs(preferId - id1) <= abs(preferId - id2) ? id1 : id2;\r             }\r             \r         }\r         return result;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestRoom\\ClosestRoom.cpp\\Solution\\closestRoom(vector<vector<int>>&,vector<vector<int>>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private:\r     void print(vector<vector<int>>& vv) {\r         cout << \"[\";\r         int i = 0;\r         for(; i<vv.size()-1; i++) {\r             cout << \"[\" << vv[i][0] << \",\" << vv[i][1] << \"],\";\r         }\r         cout << \"[\" << vv[i][0] << \",\" << vv[i][1] << \"]]\" << endl;\r     }\r public:\r     vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {\r         \r \r         for(int i=0; i<queries.size(); i++) { \r             queries[i].push_back(i);\r         }\r         \r         // sorted the rooms by size by descending order, because query the minimal size.\r         auto sort_by_size_desc =  [&](vector<int>& lhs, vector<int>&rhs) {\r             if (lhs[1] != rhs[1] ) return lhs[1] > rhs[1];\r             return lhs[0] < rhs[0];\r         };\r         sort(rooms.begin(), rooms.end(), sort_by_size_desc);\r         sort(queries.begin(), queries.end(), sort_by_size_desc);\r         //print(rooms);\r         //print(queries);\r         \r         vector<int> result(queries.size(), -1);\r         set<int> ids;\r         int i = 0;\r         for( auto& q: queries) {\r             int preferId = q[0];\r             int minSize = q[1];\r             int idx = q[2];\r             for (;i < rooms.size() && rooms[i][1] >= minSize; i++) {\r                 ids.insert(rooms[i][0]);\r             }\r             if (ids.size() <= 0 ) continue;\r             auto it = ids.lower_bound(preferId); \r             \r             int id1 = (it == ids.begin() ? -1 : *(prev(it)));\r             int id2 = (it == ids.end() ? -1 : *it);\r             \r             if (id1 == -1 || id2 == -1) {\r                 result[idx] = max(id1, id2);\r             }else{\r                 result[idx] = abs(preferId - id1) <= abs(preferId - id2) ? id1 : id2;\r             }\r             \r         }\r         return result;\r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_closestRoom_vector_vector_int_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestRoom.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> rooms;\nvector<vector<int>> queries;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode rooms */\nvector<int> rooms_element0;\nint rooms_element0_element0=2085354244;\nrooms_element0.push_back(rooms_element0_element0);\nint rooms_element0_element1=-759311688;\nrooms_element0.push_back(rooms_element0_element1);\nrooms.push_back(rooms_element0);\nvector<int> rooms_element1;\nint rooms_element1_element0=-415162704;\nrooms_element1.push_back(rooms_element1_element0);\nint rooms_element1_element1=-908253826;\nrooms_element1.push_back(rooms_element1_element1);\nint rooms_element1_element2=1989427960;\nrooms_element1.push_back(rooms_element1_element2);\nrooms.push_back(rooms_element1);\n/* VectorDataNode queries */\nvector<int> queries_element0;\nint queries_element0_element0=-1107812353;\nqueries_element0.push_back(queries_element0_element0);\nint queries_element0_element1=413193186;\nqueries_element0.push_back(queries_element0_element1);\nint queries_element0_element2=-353546555;\nqueries_element0.push_back(queries_element0_element2);\nqueries.push_back(queries_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->closestRoom(rooms,queries);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestRoom\\\\ClosestRoom.cpp\\\\Solution\\\\closestRoom(vector<vector<int>>&,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_rooms;\n\nvector<vector<int>> EXPECTED_queries;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_closestRoom_vector_vector_int_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestRoom.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> rooms;\nvector<vector<int>> queries;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode rooms */\nvector<int> rooms_element0;\nint rooms_element0_element0=2085354244;\nrooms_element0.push_back(rooms_element0_element0);\nint rooms_element0_element1=-759311688;\nrooms_element0.push_back(rooms_element0_element1);\nrooms.push_back(rooms_element0);\nvector<int> rooms_element1;\nint rooms_element1_element0=-415162704;\nrooms_element1.push_back(rooms_element1_element0);\nint rooms_element1_element1=-908253826;\nrooms_element1.push_back(rooms_element1_element1);\nint rooms_element1_element2=1989427960;\nrooms_element1.push_back(rooms_element1_element2);\nrooms.push_back(rooms_element1);\n/* VectorDataNode queries */\nvector<int> queries_element0;\nint queries_element0_element0=-1107812353;\nqueries_element0.push_back(queries_element0_element0);\nint queries_element0_element1=413193186;\nqueries_element0.push_back(queries_element0_element1);\nint queries_element0_element2=-353546555;\nqueries_element0.push_back(queries_element0_element2);\nqueries.push_back(queries_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->closestRoom(rooms,queries);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestRoom\\\\ClosestRoom.cpp\\\\Solution\\\\closestRoom(vector<vector<int>>&,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_rooms;\n\nvector<vector<int>> EXPECTED_queries;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_closestRoom_vector_vector_int_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestRoom.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> rooms;\nvector<vector<int>> queries;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode rooms */\nvector<int> rooms_element0;\nint rooms_element0_element0=2085354244;\nrooms_element0.push_back(rooms_element0_element0);\nint rooms_element0_element1=-759311688;\nrooms_element0.push_back(rooms_element0_element1);\nrooms.push_back(rooms_element0);\nvector<int> rooms_element1;\nint rooms_element1_element0=-415162704;\nrooms_element1.push_back(rooms_element1_element0);\nint rooms_element1_element1=-908253826;\nrooms_element1.push_back(rooms_element1_element1);\nint rooms_element1_element2=1989427960;\nrooms_element1.push_back(rooms_element1_element2);\nrooms.push_back(rooms_element1);\n/* VectorDataNode queries */\nvector<int> queries_element0;\nint queries_element0_element0=-1107812353;\nqueries_element0.push_back(queries_element0_element0);\nint queries_element0_element1=413193186;\nqueries_element0.push_back(queries_element0_element1);\nint queries_element0_element2=-353546555;\nqueries_element0.push_back(queries_element0_element2);\nqueries.push_back(queries_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_closestRoom_vector_vector_int_vector_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->closestRoom(rooms,queries);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestRoom\\\\ClosestRoom.cpp\\\\Solution\\\\closestRoom(vector<vector<int>>&,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_rooms;\n\nvector<vector<int>> EXPECTED_queries;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int abs(int n){\r         return n>0 ? n : -n;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestSubsequenceSum\\ClosestSubsequenceSum.cpp\\Solution\\abs(int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private: \r     int abs(int n){\r         return n>0 ? n : -n;\r     }\r     \r     void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }\r     \r     int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }\r     \r     // walk through all of element, and each element could have two chioces:\r     // add itself into sum or not. So, the time complexity is O(2^n)\r     void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }\r     \r     void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {\r         //sums.clear(); \r         sums.insert(0);\r         for (int i=start; i<=end; i++) {\r             vector<int> s(sums.begin(), sums.end());\r             for (auto n : s) {\r                 sums.insert(n + nums[i]);\r             }\r         }\r     }\r public:\r     int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }\r     \r \r };",
    "m": [
      "int findClosetDiff(set<int>& sums, int goal) {\r\n        auto it = sums.lower_bound(goal);\r\n        \r\n        // find the first item >= goal\r\n        int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r\n        // find the first item < goal\r\n        int low = (it != sums.begin()) ? *(--it) : *it; \r\n        \r\n        return min(abs(low - goal), abs(high - goal));\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_abs_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_abs_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=-379318375;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_abs_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->abs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\abs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestSubsequenceSum\\ClosestSubsequenceSum.cpp\\Solution\\printSet(set<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private: \r     int abs(int n){\r         return n>0 ? n : -n;\r     }\r     \r     void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }\r     \r     int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }\r     \r     // walk through all of element, and each element could have two chioces:\r     // add itself into sum or not. So, the time complexity is O(2^n)\r     void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }\r     \r     void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {\r         //sums.clear(); \r         sums.insert(0);\r         for (int i=start; i<=end; i++) {\r             vector<int> s(sums.begin(), sums.end());\r             for (auto n : s) {\r                 sums.insert(n + nums[i]);\r             }\r         }\r     }\r public:\r     int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }\r     \r \r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_printSet_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_printSet_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> s;\n\n/* RootDataNode STATIC */\n/* SetDataNode s */\n/* element #0 : null value -> no code */\ns.insert(s_element0);\nint s_element1=2062078205;\ns.insert(s_element1);\n/* element #2 : null value -> no code */\ns.insert(s_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printSet_set_int_random_3\");AKA_INSTANCE___Solution->printSet(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\printSet(set<int>&)\");\n\n/* error assertion */\nset<int> EXPECTED_s;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_printSet_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_printSet_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> s;\n\n/* RootDataNode STATIC */\n/* SetDataNode s */\n/* element #0 : null value -> no code */\ns.insert(s_element0);\nint s_element1=2062078205;\ns.insert(s_element1);\n/* element #2 : null value -> no code */\ns.insert(s_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printSet_set_int_random_3\");AKA_INSTANCE___Solution->printSet(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\printSet(set<int>&)\");\n\n/* error assertion */\nset<int> EXPECTED_s;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_printSet_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_printSet_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> s;\n\n/* RootDataNode STATIC */\n/* SetDataNode s */\n/* element #0 : null value -> no code */\ns.insert(s_element0);\nint s_element1=2062078205;\ns.insert(s_element1);\n/* element #2 : null value -> no code */\ns.insert(s_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printSet_set_int_random_3\");AKA_INSTANCE___Solution->printSet(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\printSet(set<int>&)\");\n\n/* error assertion */\nset<int> EXPECTED_s;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_printSet_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_printSet_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> s;\n\n/* RootDataNode STATIC */\n/* SetDataNode s */\n/* element #0 : null value -> no code */\ns.insert(s_element0);\nint s_element1=2062078205;\ns.insert(s_element1);\n/* element #2 : null value -> no code */\ns.insert(s_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printSet_set_int_random_3\");AKA_INSTANCE___Solution->printSet(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\printSet(set<int>&)\");\n\n/* error assertion */\nset<int> EXPECTED_s;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_printSet_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_printSet_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> s;\n\n/* RootDataNode STATIC */\n/* SetDataNode s */\n/* element #0 : null value -> no code */\ns.insert(s_element0);\nint s_element1=2062078205;\ns.insert(s_element1);\n/* element #2 : null value -> no code */\ns.insert(s_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printSet_set_int_random_3\");AKA_INSTANCE___Solution->printSet(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\printSet(set<int>&)\");\n\n/* error assertion */\nset<int> EXPECTED_s;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestSubsequenceSum\\ClosestSubsequenceSum.cpp\\Solution\\findClosetDiff(set<int>&,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private: \r     int abs(int n){\r         return n>0 ? n : -n;\r     }\r     \r     void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }\r     \r     int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }\r     \r     // walk through all of element, and each element could have two chioces:\r     // add itself into sum or not. So, the time complexity is O(2^n)\r     void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }\r     \r     void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {\r         //sums.clear(); \r         sums.insert(0);\r         for (int i=start; i<=end; i++) {\r             vector<int> s(sums.begin(), sums.end());\r             for (auto n : s) {\r                 sums.insert(n + nums[i]);\r             }\r         }\r     }\r public:\r     int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }\r     \r \r };",
    "m": [
      "int abs(int n){\r\n        return n>0 ? n : -n;\r\n    }",
      "int minAbsDifference(vector<int>& nums, int goal) {\r\n        set<int> sums_left, sums_right;\r\n        //seprate the arrage to two parts\r\n        int mid = nums.size() / 2;\r\n        // ---The recusive way cause the TLE problem---\r\n        //getAllSums(0, mid, nums, 0, sums_left);\r\n        //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r\n        getAllSums(0, mid, nums, sums_left);\r\n        getAllSums(mid+1, nums.size()-1, nums, sums_right);\r\n        \r\n        int minDiff = INT_MAX;\r\n        for (auto& sum : sums_left) {\r\n            // Two Sum problem:\r\n            //  - sum_left + sum_right = goal\r\n            //  - sum_right = goal = sum_left\r\n            minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r\n        }\r\n        return minDiff;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_findClosetDiff_set_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findClosetDiff_set_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> sums;\n\n\nint goal=-599725431;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\nint sums_element1=1509715816;\nsums.insert(sums_element1);\n/* element #2 : null value -> no code */\nsums.insert(sums_element2);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findClosetDiff_set_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findClosetDiff(sums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\findClosetDiff(set<int>&,int)\");\n\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_findClosetDiff_set_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findClosetDiff_set_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> sums;\n\n\nint goal=-599725431;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\nint sums_element1=1509715816;\nsums.insert(sums_element1);\n/* element #2 : null value -> no code */\nsums.insert(sums_element2);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findClosetDiff_set_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findClosetDiff(sums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\findClosetDiff(set<int>&,int)\");\n\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_findClosetDiff_set_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findClosetDiff_set_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> sums;\n\n\nint goal=-599725431;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\nint sums_element1=1509715816;\nsums.insert(sums_element1);\n/* element #2 : null value -> no code */\nsums.insert(sums_element2);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findClosetDiff_set_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findClosetDiff(sums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\findClosetDiff(set<int>&,int)\");\n\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_findClosetDiff_set_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findClosetDiff_set_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> sums;\n\n\nint goal=-599725431;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\nint sums_element1=1509715816;\nsums.insert(sums_element1);\n/* element #2 : null value -> no code */\nsums.insert(sums_element2);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findClosetDiff_set_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findClosetDiff(sums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\findClosetDiff(set<int>&,int)\");\n\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_findClosetDiff_set_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findClosetDiff_set_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nset<int> sums;\n\n\nint goal=-599725431;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\nint sums_element1=1509715816;\nsums.insert(sums_element1);\n/* element #2 : null value -> no code */\nsums.insert(sums_element2);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findClosetDiff_set_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findClosetDiff(sums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\findClosetDiff(set<int>&,int)\");\n\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestSubsequenceSum\\ClosestSubsequenceSum.cpp\\Solution\\getAllSums(int,int,vector<int>&,int,set<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private: \r     int abs(int n){\r         return n>0 ? n : -n;\r     }\r     \r     void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }\r     \r     int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }\r     \r     // walk through all of element, and each element could have two chioces:\r     // add itself into sum or not. So, the time complexity is O(2^n)\r     void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }\r     \r     void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {\r         //sums.clear(); \r         sums.insert(0);\r         for (int i=start; i<=end; i++) {\r             vector<int> s(sums.begin(), sums.end());\r             for (auto n : s) {\r                 sums.insert(n + nums[i]);\r             }\r         }\r     }\r public:\r     int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }\r     \r \r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_getAllSums_int_int_vector_int_int_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllSums_int_int_vector_int_int_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint index=-1990920058;\n\n\nint end=1767630601;\nvector<int> nums;\n\n\nint sum=2046095734;\nset<int> sums;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode index */\n/* NormalNumberDataNode end */\n/* VectorDataNode nums */\nint nums_element0=285884512;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode sum */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllSums_int_int_vector_int_int_set_int_random_3\");AKA_INSTANCE___Solution->getAllSums(index,end,nums,sum,sums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\getAllSums(int,int,vector<int>&,int,set<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getAllSums_int_int_vector_int_int_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllSums_int_int_vector_int_int_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint index=-1990920058;\n\n\nint end=1767630601;\nvector<int> nums;\n\n\nint sum=2046095734;\nset<int> sums;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode index */\n/* NormalNumberDataNode end */\n/* VectorDataNode nums */\nint nums_element0=285884512;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode sum */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllSums_int_int_vector_int_int_set_int_random_3\");AKA_INSTANCE___Solution->getAllSums(index,end,nums,sum,sums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\getAllSums(int,int,vector<int>&,int,set<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getAllSums_int_int_vector_int_int_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllSums_int_int_vector_int_int_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint index=-1990920058;\n\n\nint end=1767630601;\nvector<int> nums;\n\n\nint sum=2046095734;\nset<int> sums;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode index */\n/* NormalNumberDataNode end */\n/* VectorDataNode nums */\nint nums_element0=285884512;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode sum */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllSums_int_int_vector_int_int_set_int_random_3\");AKA_INSTANCE___Solution->getAllSums(index,end,nums,sum,sums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\getAllSums(int,int,vector<int>&,int,set<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getAllSums_int_int_vector_int_int_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllSums_int_int_vector_int_int_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint index=-1990920058;\n\n\nint end=1767630601;\nvector<int> nums;\n\n\nint sum=2046095734;\nset<int> sums;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode index */\n/* NormalNumberDataNode end */\n/* VectorDataNode nums */\nint nums_element0=285884512;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode sum */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllSums_int_int_vector_int_int_set_int_random_3\");AKA_INSTANCE___Solution->getAllSums(index,end,nums,sum,sums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\getAllSums(int,int,vector<int>&,int,set<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getAllSums_int_int_vector_int_int_set_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllSums_int_int_vector_int_int_set_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint index=-1990920058;\n\n\nint end=1767630601;\nvector<int> nums;\n\n\nint sum=2046095734;\nset<int> sums;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode index */\n/* NormalNumberDataNode end */\n/* VectorDataNode nums */\nint nums_element0=285884512;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode sum */\n/* SetDataNode sums */\n/* element #0 : null value -> no code */\nsums.insert(sums_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllSums_int_int_vector_int_int_set_int_random_3\");AKA_INSTANCE___Solution->getAllSums(index,end,nums,sum,sums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\getAllSums(int,int,vector<int>&,int,set<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\nset<int> EXPECTED_sums;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\4\\closestSubsequenceSum\\ClosestSubsequenceSum.cpp\\Solution\\minAbsDifference(vector<int>&,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r private: \r     int abs(int n){\r         return n>0 ? n : -n;\r     }\r     \r     void printSet(set<int>& s){\r         cout << \"[\";\r         for(auto& n : s) {\r             cout << n << \", \";\r         }\r         cout << \"]\" << endl;\r     }\r     \r     int findClosetDiff(set<int>& sums, int goal) {\r         auto it = sums.lower_bound(goal);\r         \r         // find the first item >= goal\r         int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r         // find the first item < goal\r         int low = (it != sums.begin()) ? *(--it) : *it; \r         \r         return min(abs(low - goal), abs(high - goal));\r     }\r     \r     // walk through all of element, and each element could have two chioces:\r     // add itself into sum or not. So, the time complexity is O(2^n)\r     void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {\r         if (index > end ) { // the latest one\r             sums.insert(sum);\r             return;\r         }\r         getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum\r         getAllSums(index+1, end, nums, sum, sums); // skip this item\r     }\r     \r     void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {\r         //sums.clear(); \r         sums.insert(0);\r         for (int i=start; i<=end; i++) {\r             vector<int> s(sums.begin(), sums.end());\r             for (auto n : s) {\r                 sums.insert(n + nums[i]);\r             }\r         }\r     }\r public:\r     int minAbsDifference(vector<int>& nums, int goal) {\r         set<int> sums_left, sums_right;\r         //seprate the arrage to two parts\r         int mid = nums.size() / 2;\r         // ---The recusive way cause the TLE problem---\r         //getAllSums(0, mid, nums, 0, sums_left);\r         //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);\r         getAllSums(0, mid, nums, sums_left);\r         getAllSums(mid+1, nums.size()-1, nums, sums_right);\r         \r         int minDiff = INT_MAX;\r         for (auto& sum : sums_left) {\r             // Two Sum problem:\r             //  - sum_left + sum_right = goal\r             //  - sum_right = goal = sum_left\r             minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));\r         }\r         return minDiff;\r     }\r     \r \r };",
    "m": [
      "int findClosetDiff(set<int>& sums, int goal) {\r\n        auto it = sums.lower_bound(goal);\r\n        \r\n        // find the first item >= goal\r\n        int high = (it == sums.end()) ? *(sums.rbegin()) : *it;\r\n        // find the first item < goal\r\n        int low = (it != sums.begin()) ? *(--it) : *it; \r\n        \r\n        return min(abs(low - goal), abs(high - goal));\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_minAbsDifference_vector_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_minAbsDifference_vector_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\ClosestSubsequenceSum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint goal=-44683554;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1567627325;\nnums.push_back(nums_element0);\nint nums_element1=-623564934;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode goal */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minAbsDifference_vector_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minAbsDifference(nums,goal);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\4\\\\closestSubsequenceSum\\\\ClosestSubsequenceSum.cpp\\\\Solution\\\\minAbsDifference(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  }
]