[
  {
    "fm": "ListNode* deleteDuplicates(ListNode* head) {\r     ListNode *dummy = new ListNode(-1);\r     dummy -> next = head;\r     ListNode *prev = dummy;\r     int prevVal;\r     \r     while (head != NULL)\r     {\r       ListNode *next = head -> next;\r \r       if (prevVal != head -> val)\r       {\r \tprevVal = head -> val;\r         prev = head;\r       }\r       else\r       {\r \tprev -> next = next;\r       }\r       head = head -> next;\r     }\r     return dummy -> next;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution083.cpp\\Solution\\deleteDuplicates(ListNode*)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   ListNode* deleteDuplicates(ListNode* head) {\r     ListNode *dummy = new ListNode(-1);\r     dummy -> next = head;\r     ListNode *prev = dummy;\r     int prevVal;\r     \r     while (head != NULL)\r     {\r       ListNode *next = head -> next;\r \r       if (prevVal != head -> val)\r       {\r \tprevVal = head -> val;\r         prev = head;\r       }\r       else\r       {\r \tprev -> next = next;\r       }\r       head = head -> next;\r     }\r     return dummy -> next;\r   }\r };",
    "m": [
      "ListNode* deleteDuplicates(ListNode* head) {\r\n    ListNode *dummy = new ListNode(-1);\r\n    dummy -> next = head;\r\n    ListNode *prev = dummy;\r\n    int prevVal;\r\n    \r\n    while (head != NULL)\r\n    {\r\n      ListNode *next = head -> next;\r\n\r\n      if (prevVal != head -> val)\r\n      {\r\n\tprevVal = head -> val;\r\n        prev = head;\r\n      }\r\n      else\r\n      {\r\n\tprev -> next = next;\r\n      }\r\n      head = head -> next;\r\n    }\r\n    return dummy -> next;\r\n  }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "ListNode* partition(ListNode* head, int x) {\r       ListNode *smallHead = new ListNode(-1);\r       ListNode *biggerHead = new ListNode(-1);\r \r       ListNode *smallTail = smallHead;\r       ListNode *biggerTail = biggerHead;\r \r       while (head != NULL)\r       {\r \tif (head -> val < x)\r \t{\r \t  smallTail -> next = head;\r \t  head = head -> next;\r \t  smallTail = smallTail -> next;\r \t  smallTail -> next = NULL;\r \t}\r \telse\r \t{\r \t  biggerTail -> next = head;\r \t  head = head -> next;\r \t  biggerTail = biggerTail -> next;\r \t  biggerTail -> next = NULL;\r \t}\r       }\r       smallTail -> next = biggerHead -> next;\r       return smallHead -> next;\r     }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution086.cpp\\Solution\\partition(ListNode*,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r   public:\r     ListNode* partition(ListNode* head, int x) {\r       ListNode *smallHead = new ListNode(-1);\r       ListNode *biggerHead = new ListNode(-1);\r \r       ListNode *smallTail = smallHead;\r       ListNode *biggerTail = biggerHead;\r \r       while (head != NULL)\r       {\r \tif (head -> val < x)\r \t{\r \t  smallTail -> next = head;\r \t  head = head -> next;\r \t  smallTail = smallTail -> next;\r \t  smallTail -> next = NULL;\r \t}\r \telse\r \t{\r \t  biggerTail -> next = head;\r \t  head = head -> next;\r \t  biggerTail = biggerTail -> next;\r \t  biggerTail -> next = NULL;\r \t}\r       }\r       smallTail -> next = biggerHead -> next;\r       return smallHead -> next;\r     }\r };",
    "m": [
      "ListNode* partition(ListNode* head, int x) {\r\n      ListNode *smallHead = new ListNode(-1);\r\n      ListNode *biggerHead = new ListNode(-1);\r\n\r\n      ListNode *smallTail = smallHead;\r\n      ListNode *biggerTail = biggerHead;\r\n\r\n      while (head != NULL)\r\n      {\r\n\tif (head -> val < x)\r\n\t{\r\n\t  smallTail -> next = head;\r\n\t  head = head -> next;\r\n\t  smallTail = smallTail -> next;\r\n\t  smallTail -> next = NULL;\r\n\t}\r\n\telse\r\n\t{\r\n\t  biggerTail -> next = head;\r\n\t  head = head -> next;\r\n\t  biggerTail = biggerTail -> next;\r\n\t  biggerTail -> next = NULL;\r\n\t}\r\n      }\r\n      smallTail -> next = biggerHead -> next;\r\n      return smallHead -> next;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_partition_ListNodemul_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_partition_ListNodemul_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution086.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-571413955;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0).val=-1457404559;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-1614070574;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).val=1785663671;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next1_x=1720476935;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_1 = new ::ListNode(head0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).val=405903920;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_1);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next2_x=-1698617890;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[2]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_2 = new ::ListNode(head0_next2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_2).val=-1710591943;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_2).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_2);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=725261957;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_1).val=-2012809745;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint x=678667443;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode x */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_partition_ListNodemul_int_random_1\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->partition(head,x);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_13\\\\solution086.cpp\\\\Solution\\\\partition(ListNode*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution086.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-571413955;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0).val=-1457404559;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-1614070574;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).val=1785663671;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next1_x=1720476935;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_1 = new ::ListNode(head0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).val=405903920;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_1);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next2_x=-1698617890;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[2]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_2 = new ::ListNode(head0_next2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_0_DOT_next_2).val=-1710591943;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_2).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_2);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=725261957;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution083.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution086.cpp\\\\partition(ListNode*,int)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_head_1).val=-2012809745;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint x=678667443;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode x */\n/* PointerStructureDataNode RETURN */\n\n"
        ],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r     int i = m - 1, j = n - 1, p = m + n - 1;\r \r     while (p >= 0)\r     {\r       if (i < 0)\r       {\r         nums1[p] = nums2[j --];\r       }\r       else if (j < 0)\r       {\r \tnums1[p] = nums1[i --];\r       }\r       else if (nums1[i] >= nums2[j])\r       {\r         nums1[p] = nums1[i --];\r       }\r       else\r       {\r \tnums1[p] = nums2[j --];\r       }\r       p --;\r     }\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution088.cpp\\Solution\\merge(vector<int>&,int,vector<int>&,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r     int i = m - 1, j = n - 1, p = m + n - 1;\r \r     while (p >= 0)\r     {\r       if (i < 0)\r       {\r         nums1[p] = nums2[j --];\r       }\r       else if (j < 0)\r       {\r \tnums1[p] = nums1[i --];\r       }\r       else if (nums1[i] >= nums2[j])\r       {\r         nums1[p] = nums1[i --];\r       }\r       else\r       {\r \tnums1[p] = nums2[j --];\r       }\r       p --;\r     }\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_merge_vector_int_int_vector_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_int_int_vector_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution088.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=7;\nvector<int> nums2;\n\n\nint n=5;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\nint nums1_element0=616909602;\nnums1.push_back(nums1_element0);\nint nums1_element1=1153844936;\nnums1.push_back(nums1_element1);\nint nums1_element2=-10250925;\nnums1.push_back(nums1_element2);\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\nint nums2_element0=-721343975;\nnums2.push_back(nums2_element0);\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_int_int_vector_int_int_random_4\");AKA_INSTANCE___Solution->merge(nums1,m,nums2,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_13\\\\solution088.cpp\\\\Solution\\\\merge(vector<int>&,int,vector<int>&,int)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums1;\n\nvector<int> EXPECTED_nums2;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution088.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=7;\nvector<int> nums2;\n\n\nint n=5;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\nint nums1_element0=616909602;\nnums1.push_back(nums1_element0);\nint nums1_element1=1153844936;\nnums1.push_back(nums1_element1);\nint nums1_element2=-10250925;\nnums1.push_back(nums1_element2);\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\nint nums2_element0=-721343975;\nnums2.push_back(nums2_element0);\n/* NormalNumberDataNode n */\n\n"
        ],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "vector<vector<int> > subsetsWithDup(vector<int>& nums) {\r     vector<vector<int> > ret;\r     vector<int> sub;\r     \r     sort(nums.begin(), nums.end());\r     backtack(nums, sub, ret, 0);\r     return ret;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution090.cpp\\Solution\\subsetsWithDup(vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   vector<vector<int> > subsetsWithDup(vector<int>& nums) {\r     vector<vector<int> > ret;\r     vector<int> sub;\r     \r     sort(nums.begin(), nums.end());\r     backtack(nums, sub, ret, 0);\r     return ret;\r   }\r \r   void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r   {\r     if (find(ret.begin(), ret.end(), sub) == ret.end())\r     {\r       ret.push_back(sub);\r     }\r     for (int i = index; i < nums.size(); i ++)\r     {\r       sub.push_back(nums[i]);\r       backtack(nums, sub, ret, i + 1);\r       sub.pop_back();\r     }\r   }\r \r \r };",
    "m": [
      "void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r\n  {\r\n    if (find(ret.begin(), ret.end(), sub) == ret.end())\r\n    {\r\n      ret.push_back(sub);\r\n    }\r\n    for (int i = index; i < nums.size(); i ++)\r\n    {\r\n      sub.push_back(nums[i]);\r\n      backtack(nums, sub, ret, i + 1);\r\n      sub.pop_back();\r\n    }\r\n  }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r   {\r     if (find(ret.begin(), ret.end(), sub) == ret.end())\r     {\r       ret.push_back(sub);\r     }\r     for (int i = index; i < nums.size(); i ++)\r     {\r       sub.push_back(nums[i]);\r       backtack(nums, sub, ret, i + 1);\r       sub.pop_back();\r     }\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution090.cpp\\Solution\\backtack(vector<int>&,vector<int>&,vector<vector<int>>&,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   vector<vector<int> > subsetsWithDup(vector<int>& nums) {\r     vector<vector<int> > ret;\r     vector<int> sub;\r     \r     sort(nums.begin(), nums.end());\r     backtack(nums, sub, ret, 0);\r     return ret;\r   }\r \r   void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r   {\r     if (find(ret.begin(), ret.end(), sub) == ret.end())\r     {\r       ret.push_back(sub);\r     }\r     for (int i = index; i < nums.size(); i ++)\r     {\r       sub.push_back(nums[i]);\r       backtack(nums, sub, ret, i + 1);\r       sub.pop_back();\r     }\r   }\r \r \r };",
    "m": [
      "vector<vector<int> > subsetsWithDup(vector<int>& nums) {\r\n    vector<vector<int> > ret;\r\n    vector<int> sub;\r\n    \r\n    sort(nums.begin(), nums.end());\r\n    backtack(nums, sub, ret, 0);\r\n    return ret;\r\n  }",
      "void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r\n  {\r\n    if (find(ret.begin(), ret.end(), sub) == ret.end())\r\n    {\r\n      ret.push_back(sub);\r\n    }\r\n    for (int i = index; i < nums.size(); i ++)\r\n    {\r\n      sub.push_back(nums[i]);\r\n      backtack(nums, sub, ret, i + 1);\r\n      sub.pop_back();\r\n    }\r\n  }",
      "void backtack(vector<int> &nums, vector<int> &sub,  vector<vector<int> > &ret, int index)\r\n  {\r\n    if (find(ret.begin(), ret.end(), sub) == ret.end())\r\n    {\r\n      ret.push_back(sub);\r\n    }\r\n    for (int i = index; i < nums.size(); i ++)\r\n    {\r\n      sub.push_back(nums[i]);\r\n      backtack(nums, sub, ret, i + 1);\r\n      sub.pop_back();\r\n    }\r\n  }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "vector<int> inorderTraversal(TreeNode* root) {\r     vector<int> ret;\r \r     if (root == NULL)\r     {\r       return ret;\r     }\r \r     stack<TreeNode *> st;\r     TreeNode *pnode = root;\r \r     while (pnode != NULL || !st.empty())\r     {\r       if (pnode != NULL)\r       {\r \tst.push(pnode);\r \tpnode = pnode -> left;\r       }\r       else\r       {\r \tpnode = st.top();\r \tst.pop();\r \tret.push_back(pnode -> val);\r \tpnode = pnode -> right;\r       }\r     }\r     return ret;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_13\\solution094.cpp\\Solution\\inorderTraversal(TreeNode*)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   vector<int> inorderTraversal(TreeNode* root) {\r     vector<int> ret;\r \r     if (root == NULL)\r     {\r       return ret;\r     }\r \r     stack<TreeNode *> st;\r     TreeNode *pnode = root;\r \r     while (pnode != NULL || !st.empty())\r     {\r       if (pnode != NULL)\r       {\r \tst.push(pnode);\r \tpnode = pnode -> left;\r       }\r       else\r       {\r \tpnode = st.top();\r \tst.pop();\r \tret.push_back(pnode -> val);\r \tpnode = pnode -> right;\r       }\r     }\r     return ret;\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_inorderTraversal_TreeNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_inorderTraversal_TreeNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution094.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1240000517;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_inorderTraversal_TreeNodemul_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->inorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_13\\\\solution094.cpp\\\\Solution\\\\inorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_inorderTraversal_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_inorderTraversal_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution094.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-161113660;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-783792784;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_inorderTraversal_TreeNodemul_random_1\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->inorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_13\\\\solution094.cpp\\\\Solution\\\\inorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution094.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1240000517;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution094.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-161113660;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-783792784;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\folder_13\\\\solution094.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\solution094.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n"
        ],
        "isAutomated": true
      }
    ]
  }
]