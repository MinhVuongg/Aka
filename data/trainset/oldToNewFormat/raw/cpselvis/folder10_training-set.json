[
  {
    "fm": "ListNode* rotateRight(ListNode* head, int k) {\r     if (head == NULL || k == 0)\r     {\r       return head;\r     }\r     ListNode *dummy = new ListNode(-1);\r     dummy -> next = head;\r     ListNode *fast = head, *slow = head;\r     int listCount = countListLength(head);\r \r     k %= listCount;\r \r     while (k --)\r     {\r       fast = fast -> next;\r     }\r \r     while (fast -> next)\r     {\r       fast = fast -> next;\r       slow = slow -> next;\r     }\r \r     if (slow -> next == NULL)\r     {\r       return head;\r     }\r     dummy -> next = slow -> next;\r     fast -> next = head;\r     slow -> next = NULL;\r     return dummy -> next;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution061.cpp\\Solution\\rotateRight(ListNode*,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   ListNode* rotateRight(ListNode* head, int k) {\r     if (head == NULL || k == 0)\r     {\r       return head;\r     }\r     ListNode *dummy = new ListNode(-1);\r     dummy -> next = head;\r     ListNode *fast = head, *slow = head;\r     int listCount = countListLength(head);\r \r     k %= listCount;\r \r     while (k --)\r     {\r       fast = fast -> next;\r     }\r \r     while (fast -> next)\r     {\r       fast = fast -> next;\r       slow = slow -> next;\r     }\r \r     if (slow -> next == NULL)\r     {\r       return head;\r     }\r     dummy -> next = slow -> next;\r     fast -> next = head;\r     slow -> next = NULL;\r     return dummy -> next;\r   }\r   int countListLength(ListNode *head)\r   {\r     int count = 0;\r     while (head != NULL)\r     {\r       head = head -> next;\r       count ++;\r     }\r     return count;\r   }\r };",
    "m": [
      "int countListLength(ListNode *head)\r\n  {\r\n    int count = 0;\r\n    while (head != NULL)\r\n    {\r\n      head = head -> next;\r\n      count ++;\r\n    }\r\n    return count;\r\n  }",
      "ListNode* rotateRight(ListNode* head, int k) {\r\n    if (head == NULL || k == 0)\r\n    {\r\n      return head;\r\n    }\r\n    ListNode *dummy = new ListNode(-1);\r\n    dummy -> next = head;\r\n    ListNode *fast = head, *slow = head;\r\n    int listCount = countListLength(head);\r\n\r\n    k %= listCount;\r\n\r\n    while (k --)\r\n    {\r\n      fast = fast -> next;\r\n    }\r\n\r\n    while (fast -> next)\r\n    {\r\n      fast = fast -> next;\r\n      slow = slow -> next;\r\n    }\r\n\r\n    if (slow -> next == NULL)\r\n    {\r\n      return head;\r\n    }\r\n    dummy -> next = slow -> next;\r\n    fast -> next = head;\r\n    slow -> next = NULL;\r\n    return dummy -> next;\r\n  }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int countListLength(ListNode *head)\r   {\r     int count = 0;\r     while (head != NULL)\r     {\r       head = head -> next;\r       count ++;\r     }\r     return count;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution061.cpp\\Solution\\countListLength(ListNode*)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   ListNode* rotateRight(ListNode* head, int k) {\r     if (head == NULL || k == 0)\r     {\r       return head;\r     }\r     ListNode *dummy = new ListNode(-1);\r     dummy -> next = head;\r     ListNode *fast = head, *slow = head;\r     int listCount = countListLength(head);\r \r     k %= listCount;\r \r     while (k --)\r     {\r       fast = fast -> next;\r     }\r \r     while (fast -> next)\r     {\r       fast = fast -> next;\r       slow = slow -> next;\r     }\r \r     if (slow -> next == NULL)\r     {\r       return head;\r     }\r     dummy -> next = slow -> next;\r     fast -> next = head;\r     slow -> next = NULL;\r     return dummy -> next;\r   }\r   int countListLength(ListNode *head)\r   {\r     int count = 0;\r     while (head != NULL)\r     {\r       head = head -> next;\r       count ++;\r     }\r     return count;\r   }\r };",
    "m": [
      "ListNode* rotateRight(ListNode* head, int k) {\r\n    if (head == NULL || k == 0)\r\n    {\r\n      return head;\r\n    }\r\n    ListNode *dummy = new ListNode(-1);\r\n    dummy -> next = head;\r\n    ListNode *fast = head, *slow = head;\r\n    int listCount = countListLength(head);\r\n\r\n    k %= listCount;\r\n\r\n    while (k --)\r\n    {\r\n      fast = fast -> next;\r\n    }\r\n\r\n    while (fast -> next)\r\n    {\r\n      fast = fast -> next;\r\n      slow = slow -> next;\r\n    }\r\n\r\n    if (slow -> next == NULL)\r\n    {\r\n      return head;\r\n    }\r\n    dummy -> next = slow -> next;\r\n    fast -> next = head;\r\n    slow -> next = NULL;\r\n    return dummy -> next;\r\n  }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_countListLength_ListNodemul_random_4(void) {\n{\nAKA_test_case_name=\"Solution_countListLength_ListNodemul_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution061.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-1636893470;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-659051239;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next1_x=0;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_1 = new ::ListNode(head0_next1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_1);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_countListLength_ListNodemul_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->countListLength(head);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_10\\\\solution061.cpp\\\\Solution\\\\countListLength(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution061.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-1636893470;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-659051239;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next1_x=0;\nAKA_mark(\"Calling: .\\\\folder_10\\\\solution061.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\solution061.cpp\\\\countListLength(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_1 = new ::ListNode(head0_next1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_1).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_1);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n"
        ],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int uniquePaths(int m, int n) {\r     if (m == 0 || n == 0)\r     {\r       return 0;\r     }\r     \r     vector<vector<int> > dp(m, vector<int>(n));\r \r     dp[0][0] = 1;\r     for (int i = 1; i < n; i ++)\r     {\r       dp[0][i] = 1;\r     }\r \r     for (int j = 1; j < m; j ++)\r     {\r       dp[j][0] = 1;\r     }\r \r     for (int i = 1; i < n; i ++ )\r     {\r       for (int j = 1; j < m; j ++)\r       {\r \tdp[j][i] = dp[j - 1][i] + dp[j][i - 1];\r       }\r     }\r     return dp[m - 1][n - 1];\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution062.cpp\\Solution\\uniquePaths(int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   int uniquePaths(int m, int n) {\r     if (m == 0 || n == 0)\r     {\r       return 0;\r     }\r     \r     vector<vector<int> > dp(m, vector<int>(n));\r \r     dp[0][0] = 1;\r     for (int i = 1; i < n; i ++)\r     {\r       dp[0][i] = 1;\r     }\r \r     for (int j = 1; j < m; j ++)\r     {\r       dp[j][0] = 1;\r     }\r \r     for (int i = 1; i < n; i ++ )\r     {\r       for (int j = 1; j < m; j ++)\r       {\r \tdp[j][i] = dp[j - 1][i] + dp[j][i - 1];\r       }\r     }\r     return dp[m - 1][n - 1];\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int uniquePathsWithObstacles(vector<vector<int> >& obstacleGrid) {\r     int m = obstacleGrid.size();\r     int n = obstacleGrid[0].size();\r     if (m == 0 || n == 0 || obstacleGrid[0][0] == 1)\r     {\r       return 0;\r     }\r \r     vector<vector<int> > dp(m, vector<int>(n, 0));\r \r     dp[0][0] = 1;\r     \r     for (int i = 1; i < m; i ++)\r     {\r       if (obstacleGrid[i][0] == 1 || dp[i - 1][0] == 0)\r       {\r \tdp[i][0] = 0;\r       }\r       else\r       {\r \tdp[i][0] = 1;\r       }\r     }\r \r     for (int j = 1; j < n; j ++)\r     {\r       if (obstacleGrid[0][j] == 1 || dp[0][j - 1] ==0)\r       {\r \tdp[0][j] = 0;\r       }\r       else\r       {\r \tdp[0][j] = 1;\r       }\r     }\r \r     for (int i = 1; i < m; i ++)\r     {\r       for (int j = 1; j < n; j ++)\r       {\r         if (obstacleGrid[i][j] == 0)\r \t{\r \t  dp[i][j] += dp[i - 1][j];\r \t}\r \tif (obstacleGrid[i][j] == 0)\r \t{\r \t  dp[i][j] += dp[i][j - 1];\r \t}\r       }\r     }\r \r     return dp[m - 1][n - 1];\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution063.cpp\\Solution\\uniquePathsWithObstacles(vector<vector<int>>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   int uniquePathsWithObstacles(vector<vector<int> >& obstacleGrid) {\r     int m = obstacleGrid.size();\r     int n = obstacleGrid[0].size();\r     if (m == 0 || n == 0 || obstacleGrid[0][0] == 1)\r     {\r       return 0;\r     }\r \r     vector<vector<int> > dp(m, vector<int>(n, 0));\r \r     dp[0][0] = 1;\r     \r     for (int i = 1; i < m; i ++)\r     {\r       if (obstacleGrid[i][0] == 1 || dp[i - 1][0] == 0)\r       {\r \tdp[i][0] = 0;\r       }\r       else\r       {\r \tdp[i][0] = 1;\r       }\r     }\r \r     for (int j = 1; j < n; j ++)\r     {\r       if (obstacleGrid[0][j] == 1 || dp[0][j - 1] ==0)\r       {\r \tdp[0][j] = 0;\r       }\r       else\r       {\r \tdp[0][j] = 1;\r       }\r     }\r \r     for (int i = 1; i < m; i ++)\r     {\r       for (int j = 1; j < n; j ++)\r       {\r         if (obstacleGrid[i][j] == 0)\r \t{\r \t  dp[i][j] += dp[i - 1][j];\r \t}\r \tif (obstacleGrid[i][j] == 0)\r \t{\r \t  dp[i][j] += dp[i][j - 1];\r \t}\r       }\r     }\r \r     return dp[m - 1][n - 1];\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int minPathSum(vector<vector<int> >& grid) {\r     int m = grid.size();\r     int n = grid[0].size();\r     if (m == 0 || n == 0)\r     {\r       return 0;\r     }\r \r     vector<vector<int> > dp(m, vector<int>(n));\r \r     dp[0][0] = grid[0][0];\r     for (int i = 1; i < m; i ++)\r     {\r       dp[i][0] = dp[i - 1][0] + grid[i][0];\r     }\r \r     for (int j = 1; j < n; j ++)\r     {\r       dp[0][j] = dp[0][j - 1] + grid[0][j];\r     }\r \r     for (int i = 1; i < m; i ++)\r     {\r       for (int j = 1; j < n; j ++)\r       {\r \tdp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\r       }\r     }\r \r     return dp[m - 1][n - 1];\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution064.cpp\\Solution\\minPathSum(vector<vector<int>>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   int minPathSum(vector<vector<int> >& grid) {\r     int m = grid.size();\r     int n = grid[0].size();\r     if (m == 0 || n == 0)\r     {\r       return 0;\r     }\r \r     vector<vector<int> > dp(m, vector<int>(n));\r \r     dp[0][0] = grid[0][0];\r     for (int i = 1; i < m; i ++)\r     {\r       dp[i][0] = dp[i - 1][0] + grid[i][0];\r     }\r \r     for (int j = 1; j < n; j ++)\r     {\r       dp[0][j] = dp[0][j - 1] + grid[0][j];\r     }\r \r     for (int i = 1; i < m; i ++)\r     {\r       for (int j = 1; j < n; j ++)\r       {\r \tdp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\r       }\r     }\r \r     return dp[m - 1][n - 1];\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_minPathSum_vector_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_minPathSum_vector_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution064.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> grid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode grid */\nvector<int> grid_element0;\nint grid_element0_element0=-1771244968;\ngrid_element0.push_back(grid_element0_element0);\nint grid_element0_element1=1026033017;\ngrid_element0.push_back(grid_element0_element1);\nint grid_element0_element2=86768109;\ngrid_element0.push_back(grid_element0_element2);\ngrid.push_back(grid_element0);\nvector<int> grid_element1;\nint grid_element1_element0=151331042;\ngrid_element1.push_back(grid_element1_element0);\ngrid.push_back(grid_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minPathSum_vector_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minPathSum(grid);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_10\\\\solution064.cpp\\\\Solution\\\\minPathSum(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_grid;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution064.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> grid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode grid */\nvector<int> grid_element0;\nint grid_element0_element0=-1771244968;\ngrid_element0.push_back(grid_element0_element0);\nint grid_element0_element1=1026033017;\ngrid_element0.push_back(grid_element0_element1);\nint grid_element0_element2=86768109;\ngrid_element0.push_back(grid_element0_element2);\ngrid.push_back(grid_element0);\nvector<int> grid_element1;\nint grid_element1_element0=151331042;\ngrid_element1.push_back(grid_element1_element0);\ngrid.push_back(grid_element1);\n/* NormalNumberDataNode RETURN */\n\n"
        ],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "vector<int> plusOne(vector<int>& digits) {\r     int i = digits.size() - 1, carry = 1;\r \r     while (i >= 0)\r     {\r       int sum = digits[i] + carry;\r       if (sum >= 10)\r       {\r \tdigits[i] = sum - 10;\r \tcarry = 1;\r       }\r       else\r       {\r \tdigits[i] = sum;\r \tcarry = 0;\r       }\r       i --;\r     }\r     if (carry == 1)\r     {\r       digits.insert(digits.begin(), 1);\r     }\r \r     return digits;\r   }",
    "f": [],
    "path_fm": "D:\\py\\test\\folder_10\\solution066.cpp\\Solution\\plusOne(vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r   vector<int> plusOne(vector<int>& digits) {\r     int i = digits.size() - 1, carry = 1;\r \r     while (i >= 0)\r     {\r       int sum = digits[i] + carry;\r       if (sum >= 10)\r       {\r \tdigits[i] = sum - 10;\r \tcarry = 1;\r       }\r       else\r       {\r \tdigits[i] = sum;\r \tcarry = 0;\r       }\r       i --;\r     }\r     if (carry == 1)\r     {\r       digits.insert(digits.begin(), 1);\r     }\r \r     return digits;\r   }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_plusOne_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_plusOne_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution066.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> digits;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode digits */\nint digits_element0=-1048469299;\ndigits.push_back(digits_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_plusOne_vector_int_random_4\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->plusOne(digits);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_10\\\\solution066.cpp\\\\Solution\\\\plusOne(vector<int>&)\");\n\n\nvector<int> EXPECTED_digits;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_plusOne_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_plusOne_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution066.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> digits;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode digits */\nint digits_element0=630881624;\ndigits.push_back(digits_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_plusOne_vector_int_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->plusOne(digits);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_10\\\\solution066.cpp\\\\Solution\\\\plusOne(vector<int>&)\");\n\n\nvector<int> EXPECTED_digits;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution066.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> digits;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode digits */\nint digits_element0=-1048469299;\ndigits.push_back(digits_element0);\n/* VectorDataNode RETURN */\n\n",
          "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\solution066.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> digits;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode digits */\nint digits_element0=630881624;\ndigits.push_back(digits_element0);\n/* VectorDataNode RETURN */\n\n"
        ],
        "isAutomated": true
      }
    ]
  }
]