[
  {
    "fm": "void moveZeroes(int* nums, int numsSize)\r {\r \tint i;\r \tint temp;\r \tint nonZeroCount = 0;\r \tfor (i = 0; i<numsSize; i++)\r \t{\r \t\tif (nums[i] != 0)\r \t\t{\r \t\t\tnums[nonZeroCount] = nums[i];\r \t\t\t//nums[i]=0;\r \t\t\tnonZeroCount++;\r \t\t}\r \t\tif (nums[i] == 0)\r \t\t\tcontinue;\r \t}\r \tfor (i = nonZeroCount; i<numsSize; i++)\r \t{\r \t\tnums[i] = 0;\r \t}\r }",
    "f": [],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_283 Move Zeroes\\_283 Move Zeroes.cpp\\moveZeroes(int*,int)",
    "c": [],
    "fc": "",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_moveZeroes_intmul_int_random_2(void) {\n{\nAKA_test_case_name=\"moveZeroes_intmul_int_random_2\";\n\n// set up\n;\n\nint AKA_ARRAY_INIT_nums[3];\n\n\nint AKA_ARRAY_INIT_nums_0=-299672171;\nAKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0;\n\n\nint AKA_ARRAY_INIT_nums_1=80937251;\nAKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1;\n\n\nint AKA_ARRAY_INIT_nums_2=1809585675;\nAKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2;\n\nint* nums = AKA_ARRAY_INIT_nums;\n\n\nint numsSize=7;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode nums */\n/* NormalNumberDataNode numsSize */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test moveZeroes_intmul_int_random_2\");moveZeroes(nums,numsSize);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_283 Move Zeroes\\\\_283 Move Zeroes.cpp\\\\moveZeroes(int*,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int findMaxLength1(int* nums, int numsSize) {\r \tint diff = 0, maxLength = 0;\r \tfor (int start = 0; start < numsSize; start++) {\r \t\tdiff = 0;\r \t\tfor (int i = start; i < numsSize; i++) {\r \t\t\tdiff += (nums[i] == 1 ? 1 : -1);\r \t\t\tif (diff == 0) {\r \t\t\t\tint length = i - start + 1;\r \t\t\t\tmaxLength = length > maxLength ? length : maxLength;\r \t\t\t}\r \t\t}\r \t}\r \treturn maxLength;\r }",
    "f": [],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_525 Contiguous Array\\_525 Contiguous Array.cpp\\findMaxLength1(int*,int)",
    "c": [],
    "fc": "",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_findMaxLength1_intmul_int_random_3(void) {\n{\nAKA_test_case_name=\"findMaxLength1_intmul_int_random_3\";\n\n// set up\n;\n\nint AKA_ARRAY_INIT_nums[3];\n\n\nint AKA_ARRAY_INIT_nums_0=1724978225;\nAKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0;\n\n\nint AKA_ARRAY_INIT_nums_1=907840714;\nAKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1;\n\n\nint AKA_ARRAY_INIT_nums_2=1710867304;\nAKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2;\n\nint* nums = AKA_ARRAY_INIT_nums;\n\n\nint numsSize=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode nums */\n/* NormalNumberDataNode numsSize */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test findMaxLength1_intmul_int_random_3\");int AKA_ACTUAL_OUTPUT=findMaxLength1(nums,numsSize);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_525 Contiguous Array\\\\_525 Contiguous Array.cpp\\\\findMaxLength1(int*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int findMaxLength2(int* nums, int numsSize) {\r \tint diff = 0, maxLength = 0;\r \tfor (int start = 0; start < numsSize; start++) {\r \t\tint iStart = start;\r \t\tif (maxLength) {\r \t\t\tdiff = (nums[start - 1] == 0 ? 1 : -1);\r \t\t\tiStart = start + maxLength - 1;\r \t\t}\r \t\telse {\r \t\t\tdiff = 0;\r \t\t}\r \t\tfor (int i = iStart; i < numsSize; i++) {\r \t\t\tdiff += (nums[i] == 1 ? 1 : -1);\r \t\t\tif (diff == 0) {\r \t\t\t\tmaxLength += i - iStart + 1;\r \t\t\t}\r \t\t}\r \t}\r \treturn maxLength;\r }",
    "f": [],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_525 Contiguous Array\\_525 Contiguous Array.cpp\\findMaxLength2(int*,int)",
    "c": [],
    "fc": "",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_findMaxLength2_intmul_int_random_3(void) {\n{\nAKA_test_case_name=\"findMaxLength2_intmul_int_random_3\";\n\n// set up\n;\n\nint AKA_ARRAY_INIT_nums[2];\n\n\nint AKA_ARRAY_INIT_nums_0=-925577948;\nAKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0;\n\n\nint AKA_ARRAY_INIT_nums_1=-1012031715;\nAKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1;\n\nint* nums = AKA_ARRAY_INIT_nums;\n\n\nint numsSize=1;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode nums */\n/* NormalNumberDataNode numsSize */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test findMaxLength2_intmul_int_random_3\");int AKA_ACTUAL_OUTPUT=findMaxLength2(nums,numsSize);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_525 Contiguous Array\\\\_525 Contiguous Array.cpp\\\\findMaxLength2(int*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int findMaxLength(int* nums, int numsSize) {\r \tint *sumMap = (int*)calloc(2*numsSize+1, sizeof(int));\r \tfor(int i=0;i<2 * numsSize + 1;i++){\r \t\tsumMap[i] = numsSize + 1;\r \t}\r \tsumMap[0 + numsSize] = -1;\r \r \tint sum = 0, maxLength = 0;\r \tfor (int i = 0; i < numsSize; i++) {\r \t\tsum += (nums[i] == 1 ? 1 : -1);\r \t\tif (sumMap[sum + numsSize] == numsSize + 1) {\r \t\t\tsumMap[sum + numsSize] = i;\r \t\t}\r \t\telse {\r \t\t\tint curLength = i - sumMap[sum + numsSize];\r \t\t\tmaxLength = maxLength > curLength ? maxLength : curLength;\r \t\t}\r \t}\r \r \treturn maxLength;\r }",
    "f": [],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_525 Contiguous Array\\_525 Contiguous Array.cpp\\findMaxLength(int*,int)",
    "c": [],
    "fc": "",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_findMaxLength_intmul_int_random_4(void) {\n{\nAKA_test_case_name=\"findMaxLength_intmul_int_random_4\";\n\n// set up\n;\n\nint AKA_ARRAY_INIT_nums[3];\n\n\nint AKA_ARRAY_INIT_nums_0=-1187104485;\nAKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0;\n\n\nint AKA_ARRAY_INIT_nums_1=1019770646;\nAKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1;\n\n\nint AKA_ARRAY_INIT_nums_2=-1434322140;\nAKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2;\n\nint* nums = AKA_ARRAY_INIT_nums;\n\n\nint numsSize=10;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode nums */\n/* NormalNumberDataNode numsSize */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test findMaxLength_intmul_int_random_4\");int AKA_ACTUAL_OUTPUT=findMaxLength(nums,numsSize);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_525 Contiguous Array\\\\_525 Contiguous Array.cpp\\\\findMaxLength(int*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {\r \t\tif (board[click[0]][click[1]] == 'M') {\r \t\t\tboard[click[0]][click[1]] = 'X';\r \t\t\treturn board;\r \t\t}\r \r \t\t// ʼԱ\r \t\toriginal_map.assign(board.begin(), board.end());\r \t\tvector<char> t(board[0].size(), 0);\r \t\tfor (int i = 0; i < board.size(); i++) {\r \t\t\tstatus_map.push_back(t);\r \t\t}\r \t\tupdatestatus_map();\r \t\t// ӡ\r \t\t//print2Dvector(status_map);\r \r \t\tif (status_map[click[0]][click[1]] > 0 ) {\r \t\t\toriginal_map[click[0]][click[1]] = status_map[click[0]][click[1]] + 0x30;\r \t\t\treturn original_map;\r \t\t}\r \r \t\tdfs(click[0], click[1]);\r \r \t\treturn original_map;\r \t}",
    "f": [
      "vector<vector<char>> original_map;",
      "vector<vector<char>> status_map;"
    ],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_529_Minesweeper\\_529_Minesweeper.cpp\\Solution\\updateBoard(vector<vector<char>>&,vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r \tvector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {\r \t\tif (board[click[0]][click[1]] == 'M') {\r \t\t\tboard[click[0]][click[1]] = 'X';\r \t\t\treturn board;\r \t\t}\r \r \t\t// ʼԱ\r \t\toriginal_map.assign(board.begin(), board.end());\r \t\tvector<char> t(board[0].size(), 0);\r \t\tfor (int i = 0; i < board.size(); i++) {\r \t\t\tstatus_map.push_back(t);\r \t\t}\r \t\tupdatestatus_map();\r \t\t// ӡ\r \t\t//print2Dvector(status_map);\r \r \t\tif (status_map[click[0]][click[1]] > 0 ) {\r \t\t\toriginal_map[click[0]][click[1]] = status_map[click[0]][click[1]] + 0x30;\r \t\t\treturn original_map;\r \t\t}\r \r \t\tdfs(click[0], click[1]);\r \r \t\treturn original_map;\r \t}\r private:\r \tvector<vector<char>> original_map;\r \tvector<vector<char>> status_map;\r \r \tvoid updatestatus_map() {\r \t\tfor (int i = 0; i < original_map.size(); i++) {\r \t\t\tfor (int j = 0; j < original_map[i].size(); j++) {\r \t\t\t\tif (original_map[i][j] == 'M') {\r \t\t\t\t\tsetNumsAroundMine(i, j);\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \t}\r \tvoid setNumsAroundMine(int x, int y) {\r \t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r \t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r \t\t\t\tstatus_map[i][j]++;\r \t\t\t}\r \t\t}\r \t\tstatus_map[x][y] = -9;\r \t}\r \r \tvoid dfs(int x, int y) {\r \t\tif (status_map[x][y] > 0) {\r \t\t\toriginal_map[x][y] = status_map[x][y] + 0x30;\r \t\t\treturn;\r \t\t}\r \t\telse if (status_map[x][y] < 0) {\r \t\t\treturn;\r \t\t}\r \r \t\toriginal_map[x][y] = 'B';\r \t\t// ӡ\r \t\t//print2Dvector(original_map);\r \r \t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r \t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r \t\t\t\tif ((x == i && y == j) || original_map[i][j]!='E')\r \t\t\t\t\tcontinue;\r \t\t\t\tdfs(i,j);\r \t\t\t}\r \t\t}\r \t}\r };",
    "m": [
      "void updatestatus_map() {\r\n\t\tfor (int i = 0; i < original_map.size(); i++) {\r\n\t\t\tfor (int j = 0; j < original_map[i].size(); j++) {\r\n\t\t\t\tif (original_map[i][j] == 'M') {\r\n\t\t\t\t\tsetNumsAroundMine(i, j);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}",
      "void dfs(int x, int y) {\r\n\t\tif (status_map[x][y] > 0) {\r\n\t\t\toriginal_map[x][y] = status_map[x][y] + 0x30;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (status_map[x][y] < 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\toriginal_map[x][y] = 'B';\r\n\t\t// ӡ\r\n\t\t//print2Dvector(original_map);\r\n\r\n\t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r\n\t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r\n\t\t\t\tif ((x == i && y == j) || original_map[i][j]!='E')\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tdfs(i,j);\r\n\t\t\t}\r\n\t\t}\r\n\t}"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_updateBoard_vector_vector_char_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_updateBoard_vector_vector_char_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\_529_Minesweeper.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* VectorDataNode original_map */\n/* VectorDataNode status_map */\n\n\nvector<vector<char>> board;\nvector<int> click;\nvector<vector<char>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode board */\nvector<char> board_element0;\nchar board_element0_element0=83;\nboard_element0.push_back(board_element0_element0);\nboard.push_back(board_element0);\n/* VectorDataNode click */\nint click_element0=866038439;\nclick.push_back(click_element0);\nint click_element1=-1117310019;\nclick.push_back(click_element1);\nint click_element2=-1892685060;\nclick.push_back(click_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_updateBoard_vector_vector_char_vector_int_random_1\");vector<vector<char>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->updateBoard(board,click);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_529_Minesweeper\\\\_529_Minesweeper.cpp\\\\Solution\\\\updateBoard(vector<vector<char>>&,vector<int>&)\");\n\n\nvector<vector<char>> EXPECTED_board;\n\nvector<int> EXPECTED_click;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void updatestatus_map() {\r \t\tfor (int i = 0; i < original_map.size(); i++) {\r \t\t\tfor (int j = 0; j < original_map[i].size(); j++) {\r \t\t\t\tif (original_map[i][j] == 'M') {\r \t\t\t\t\tsetNumsAroundMine(i, j);\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \t}",
    "f": [
      "vector<vector<char>> original_map;",
      "vector<vector<char>> status_map;"
    ],
    "path_fm": "C:\\Users\\admin\\zqxl_leetcode\\Leetcode\\_529_Minesweeper\\_529_Minesweeper.cpp\\Solution\\updatestatus_map()",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r \tvector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {\r \t\tif (board[click[0]][click[1]] == 'M') {\r \t\t\tboard[click[0]][click[1]] = 'X';\r \t\t\treturn board;\r \t\t}\r \r \t\t// ʼԱ\r \t\toriginal_map.assign(board.begin(), board.end());\r \t\tvector<char> t(board[0].size(), 0);\r \t\tfor (int i = 0; i < board.size(); i++) {\r \t\t\tstatus_map.push_back(t);\r \t\t}\r \t\tupdatestatus_map();\r \t\t// ӡ\r \t\t//print2Dvector(status_map);\r \r \t\tif (status_map[click[0]][click[1]] > 0 ) {\r \t\t\toriginal_map[click[0]][click[1]] = status_map[click[0]][click[1]] + 0x30;\r \t\t\treturn original_map;\r \t\t}\r \r \t\tdfs(click[0], click[1]);\r \r \t\treturn original_map;\r \t}\r private:\r \tvector<vector<char>> original_map;\r \tvector<vector<char>> status_map;\r \r \tvoid updatestatus_map() {\r \t\tfor (int i = 0; i < original_map.size(); i++) {\r \t\t\tfor (int j = 0; j < original_map[i].size(); j++) {\r \t\t\t\tif (original_map[i][j] == 'M') {\r \t\t\t\t\tsetNumsAroundMine(i, j);\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \t}\r \tvoid setNumsAroundMine(int x, int y) {\r \t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r \t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r \t\t\t\tstatus_map[i][j]++;\r \t\t\t}\r \t\t}\r \t\tstatus_map[x][y] = -9;\r \t}\r \r \tvoid dfs(int x, int y) {\r \t\tif (status_map[x][y] > 0) {\r \t\t\toriginal_map[x][y] = status_map[x][y] + 0x30;\r \t\t\treturn;\r \t\t}\r \t\telse if (status_map[x][y] < 0) {\r \t\t\treturn;\r \t\t}\r \r \t\toriginal_map[x][y] = 'B';\r \t\t// ӡ\r \t\t//print2Dvector(original_map);\r \r \t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r \t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r \t\t\t\tif ((x == i && y == j) || original_map[i][j]!='E')\r \t\t\t\t\tcontinue;\r \t\t\t\tdfs(i,j);\r \t\t\t}\r \t\t}\r \t}\r };",
    "m": [
      "vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {\r\n\t\tif (board[click[0]][click[1]] == 'M') {\r\n\t\t\tboard[click[0]][click[1]] = 'X';\r\n\t\t\treturn board;\r\n\t\t}\r\n\r\n\t\t// ʼԱ\r\n\t\toriginal_map.assign(board.begin(), board.end());\r\n\t\tvector<char> t(board[0].size(), 0);\r\n\t\tfor (int i = 0; i < board.size(); i++) {\r\n\t\t\tstatus_map.push_back(t);\r\n\t\t}\r\n\t\tupdatestatus_map();\r\n\t\t// ӡ\r\n\t\t//print2Dvector(status_map);\r\n\r\n\t\tif (status_map[click[0]][click[1]] > 0 ) {\r\n\t\t\toriginal_map[click[0]][click[1]] = status_map[click[0]][click[1]] + 0x30;\r\n\t\t\treturn original_map;\r\n\t\t}\r\n\r\n\t\tdfs(click[0], click[1]);\r\n\r\n\t\treturn original_map;\r\n\t}",
      "void setNumsAroundMine(int x, int y) {\r\n\t\tfor (int i = max(0, x - 1); i < min(status_map.size(), x + 2); i++) {\r\n\t\t\tfor (int j = max(0, y - 1); j < min(status_map[i].size(), y + 2); j++) {\r\n\t\t\t\tstatus_map[i][j]++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstatus_map[x][y] = -9;\r\n\t}"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_updatestatus_map_random_0(void) {\n{\nAKA_test_case_name=\"Solution_updatestatus_map_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\_529_Minesweeper.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* VectorDataNode original_map */\n/* VectorDataNode status_map */\n\n\n\n/* RootDataNode STATIC */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_updatestatus_map_random_0\");AKA_INSTANCE___Solution->updatestatus_map();\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Leetcode\\\\_529_Minesweeper\\\\_529_Minesweeper.cpp\\\\Solution\\\\updatestatus_map()\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  }
]