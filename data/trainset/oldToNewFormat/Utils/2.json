[
  {
    "fm": "bool buddyStrings(string A, string B) {\r         if (A.size() != B.size()) return false;\r         if (A.size()<2) return false;\r         \r         bool bRepeat = false;\r         bool map[26] = {false};\r         int idx[2], diffCnt=0;\r         \r         for (int i=0; i<A.size(); i++){\r             if (map[A[i]-'a']) { bRepeat = true;}\r             map[A[i]-'a']=true;\r             if ( A[i] != B[i] ) {\r                 if (diffCnt>=2) return false;\r                 idx[diffCnt++] = i;\r                 \r             }\r         }\r         //if A == B and there has repeated chars , then return true\r         if (diffCnt==0 && bRepeat) return true;\r         \r         return (A[idx[0]] == B[idx[1]] && A[idx[1]] == B[idx[0]]);\r         \r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\buddyStrings\\BuddyStrings.cpp\\Solution\\buddyStrings(string,string)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     bool buddyStrings(string A, string B) {\r         if (A.size() != B.size()) return false;\r         if (A.size()<2) return false;\r         \r         bool bRepeat = false;\r         bool map[26] = {false};\r         int idx[2], diffCnt=0;\r         \r         for (int i=0; i<A.size(); i++){\r             if (map[A[i]-'a']) { bRepeat = true;}\r             map[A[i]-'a']=true;\r             if ( A[i] != B[i] ) {\r                 if (diffCnt>=2) return false;\r                 idx[diffCnt++] = i;\r                 \r             }\r         }\r         //if A == B and there has repeated chars , then return true\r         if (diffCnt==0 && bRepeat) return true;\r         \r         return (A[idx[0]] == B[idx[1]] && A[idx[1]] == B[idx[0]]);\r         \r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_buddyStrings_string_string_random_1(void) {\n{\nAKA_test_case_name=\"Solution_buddyStrings_string_string_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BuddyStrings.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName468129 = new char[2];akaRandomName468129[0] = -41;akaRandomName468129[1] = '\\0';string A=akaRandomName468129;\nchar* akaRandomName904269 = new char[2];akaRandomName904269[0] = 95;akaRandomName904269[1] = '\\0';string B=akaRandomName904269;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode A */\n/* NormalStringDataNode B */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_buddyStrings_string_string_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->buddyStrings(A,B);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\buddyStrings\\\\BuddyStrings.cpp\\\\Solution\\\\buddyStrings(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int total(long h){\r         return h * (h+1) * (h+2) / 6;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\buildingBoxes\\BuildingBoxes.cpp\\Solution1\\total(long)",
    "c": [
      ""
    ],
    "fc": "class Solution1 {\r private:\r     int total(long h){\r         return h * (h+1) * (h+2) / 6;\r     }\r public:\r     int minimumBoxes(int n) {\r         //find the maxiumn height which total(height) <= n\r         //binary search\r         int left = 1, right = pow(6l*n, 1.0/3) ;\r         while(left <= right){\r             int mid = left + (right - left) / 2;\r             int t = total(mid);\r             if ( t == n ) return mid*(mid+1l)/2;\r             if ( t < n) left = mid + 1;\r             else right = mid - 1;\r         }\r         int height = right;\r         int remind = n - total(height);\r         int bottom = height * (height+1l)/2 ;\r         //cout << \"n=\" << n << \", height=\" << height << \r         //    \", bottom = \" << bottom << \", remind=\" << remind << endl;\r         \r         //find teh maxium h which sum(1..h) <= remind\r         //binary search\r         left = 1; right = sqrt(2*remind);\r         while ( left <= right) {\r             int mid = left + (right - left)/2;\r             int h = mid*(mid+1)/2;\r             if ( h == remind) return bottom + mid;\r             if ( h < remind) left = mid + 1;\r             else right = mid -1;\r         }\r         //cout << \"left=\" << left << \", right=\" << right << endl;\r         return bottom + left;\r     }\r };",
    "m": [
      "int minimumBoxes(int n) {\r\n        //find the maxiumn height which total(height) <= n\r\n        //binary search\r\n        int left = 1, right = pow(6l*n, 1.0/3) ;\r\n        while(left <= right){\r\n            int mid = left + (right - left) / 2;\r\n            int t = total(mid);\r\n            if ( t == n ) return mid*(mid+1l)/2;\r\n            if ( t < n) left = mid + 1;\r\n            else right = mid - 1;\r\n        }\r\n        int height = right;\r\n        int remind = n - total(height);\r\n        int bottom = height * (height+1l)/2 ;\r\n        //cout << \"n=\" << n << \", height=\" << height << \r\n        //    \", bottom = \" << bottom << \", remind=\" << remind << endl;\r\n        \r\n        //find teh maxium h which sum(1..h) <= remind\r\n        //binary search\r\n        left = 1; right = sqrt(2*remind);\r\n        while ( left <= right) {\r\n            int mid = left + (right - left)/2;\r\n            int h = mid*(mid+1)/2;\r\n            if ( h == remind) return bottom + mid;\r\n            if ( h < remind) left = mid + 1;\r\n            else right = mid -1;\r\n        }\r\n        //cout << \"left=\" << left << \", right=\" << right << endl;\r\n        return bottom + left;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution1_total_long_random_0(void) {\n{\nAKA_test_case_name=\"Solution1_total_long_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution1 */\n/* ConstructorDataNode Solution1() */\nAKA_mark(\"Calling: \\\\Solution1()|ROOT\\\\BuildingBoxes.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution1\\\\AKA_INSTANCE___Solution1\\\\Solution1()\");AKA_fCall++;AKA_INSTANCE___Solution1 = new ::Solution1();\n\n\n\n\nlong h=201542861;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode h */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution1_total_long_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution1->total(h);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\buildingBoxes\\\\BuildingBoxes.cpp\\\\Solution1\\\\total(long)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int minimumBoxes(int n) {\r         //find the maxiumn height which total(height) <= n\r         //binary search\r         int left = 1, right = pow(6l*n, 1.0/3) ;\r         while(left <= right){\r             int mid = left + (right - left) / 2;\r             int t = total(mid);\r             if ( t == n ) return mid*(mid+1l)/2;\r             if ( t < n) left = mid + 1;\r             else right = mid - 1;\r         }\r         int height = right;\r         int remind = n - total(height);\r         int bottom = height * (height+1l)/2 ;\r         //cout << \"n=\" << n << \", height=\" << height << \r         //    \", bottom = \" << bottom << \", remind=\" << remind << endl;\r         \r         //find teh maxium h which sum(1..h) <= remind\r         //binary search\r         left = 1; right = sqrt(2*remind);\r         while ( left <= right) {\r             int mid = left + (right - left)/2;\r             int h = mid*(mid+1)/2;\r             if ( h == remind) return bottom + mid;\r             if ( h < remind) left = mid + 1;\r             else right = mid -1;\r         }\r         //cout << \"left=\" << left << \", right=\" << right << endl;\r         return bottom + left;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\buildingBoxes\\BuildingBoxes.cpp\\Solution1\\minimumBoxes(int)",
    "c": [
      ""
    ],
    "fc": "class Solution1 {\r private:\r     int total(long h){\r         return h * (h+1) * (h+2) / 6;\r     }\r public:\r     int minimumBoxes(int n) {\r         //find the maxiumn height which total(height) <= n\r         //binary search\r         int left = 1, right = pow(6l*n, 1.0/3) ;\r         while(left <= right){\r             int mid = left + (right - left) / 2;\r             int t = total(mid);\r             if ( t == n ) return mid*(mid+1l)/2;\r             if ( t < n) left = mid + 1;\r             else right = mid - 1;\r         }\r         int height = right;\r         int remind = n - total(height);\r         int bottom = height * (height+1l)/2 ;\r         //cout << \"n=\" << n << \", height=\" << height << \r         //    \", bottom = \" << bottom << \", remind=\" << remind << endl;\r         \r         //find teh maxium h which sum(1..h) <= remind\r         //binary search\r         left = 1; right = sqrt(2*remind);\r         while ( left <= right) {\r             int mid = left + (right - left)/2;\r             int h = mid*(mid+1)/2;\r             if ( h == remind) return bottom + mid;\r             if ( h < remind) left = mid + 1;\r             else right = mid -1;\r         }\r         //cout << \"left=\" << left << \", right=\" << right << endl;\r         return bottom + left;\r     }\r };",
    "m": [
      "int total(long h){\r\n        return h * (h+1) * (h+2) / 6;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution1_minimumBoxes_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution1_minimumBoxes_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution1 */\n/* ConstructorDataNode Solution1() */\nAKA_mark(\"Calling: \\\\Solution1()|ROOT\\\\BuildingBoxes.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution1\\\\AKA_INSTANCE___Solution1\\\\Solution1()\");AKA_fCall++;AKA_INSTANCE___Solution1 = new ::Solution1();\n\n\n\n\nint n=1067445116;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution1_minimumBoxes_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution1->minimumBoxes(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\buildingBoxes\\\\BuildingBoxes.cpp\\\\Solution1\\\\minimumBoxes(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int bulbSwitch(int n) {\r         return (int)sqrt(n);\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bulbSwitcher\\bulbSwitcher.cpp\\Solution\\bulbSwitch(int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int bulbSwitch(int n) {\r         return (int)sqrt(n);\r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_bulbSwitch_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_bulbSwitch_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bulbSwitcher.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=-1793982043;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_bulbSwitch_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->bulbSwitch(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bulbSwitcher\\\\bulbSwitcher.cpp\\\\Solution\\\\bulbSwitch(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int flipLights(int n, int m) {\r         if (m == 0 || n == 0) return 1;\r         if (n == 1) return 2;\r         if (n == 2) return m == 1? 3:4;\r         if (m == 1) return 4;\r         return m==2 ? 7 :8;\r         \r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bulbSwitcher\\BulbSwitcher.II.cpp\\Solution\\flipLights(int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int flipLights(int n, int m) {\r         if (m == 0 || n == 0) return 1;\r         if (n == 1) return 2;\r         if (n == 2) return m == 1? 3:4;\r         if (m == 1) return 4;\r         return m==2 ? 7 :8;\r         \r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_flipLights_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_flipLights_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BulbSwitcher.II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=-28357879;\n\n\nint m=-995990536;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_flipLights_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->flipLights(n,m);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bulbSwitcher\\\\BulbSwitcher.II.cpp\\\\Solution\\\\flipLights(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int numTimesAllBlue(vector<int>& light) {\r         int n = light.size();\r         vector<bool> on(n, false);\r         int left = 0; //tracking the most left place that all bubls are truned on.\r         int result = 0;\r         for(int i=0; i<light.size(); i++){\r             on[light[i]-1] = true;\r             while (left < n && on[left]) left++;\r             //if the bulbs are on left is equal to current bulbs we trun on.\r             //then they all are blue.\r             if (left == i+1) result++; \r         }\r         return result;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bulbSwitcher\\BulbSwitcher.III.cpp\\Solution\\numTimesAllBlue(vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int numTimesAllBlue(vector<int>& light) {\r         int n = light.size();\r         vector<bool> on(n, false);\r         int left = 0; //tracking the most left place that all bubls are truned on.\r         int result = 0;\r         for(int i=0; i<light.size(); i++){\r             on[light[i]-1] = true;\r             while (left < n && on[left]) left++;\r             //if the bulbs are on left is equal to current bulbs we trun on.\r             //then they all are blue.\r             if (left == i+1) result++; \r         }\r         return result;\r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_numTimesAllBlue_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_numTimesAllBlue_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BulbSwitcher.III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> light;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode light */\nint light_element0=-742171133;\nlight.push_back(light_element0);\nint light_element1=198217015;\nlight.push_back(light_element1);\nint light_element2=67053058;\nlight.push_back(light_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numTimesAllBlue_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numTimesAllBlue(light);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bulbSwitcher\\\\BulbSwitcher.III.cpp\\\\Solution\\\\numTimesAllBlue(vector<int>&)\");\n\n\nvector<int> EXPECTED_light;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int minFlips(string target) {\r         //flip the target to initalization\r         int flip = 0;\r         for(auto state : target) {\r             if (state == '0' && flip % 2 == 1 ) flip++;\r             if (state == '1' && flip % 2 == 0 ) flip++;\r         }\r         return flip;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bulbSwitcher\\BulbSwitcher.IV.cpp\\Solution\\minFlips(string)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int minFlips(string target) {\r         //flip the target to initalization\r         int flip = 0;\r         for(auto state : target) {\r             if (state == '0' && flip % 2 == 1 ) flip++;\r             if (state == '1' && flip % 2 == 0 ) flip++;\r         }\r         return flip;\r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_minFlips_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_minFlips_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BulbSwitcher.IV.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName411191 = new char[2];akaRandomName411191[0] = -91;akaRandomName411191[1] = '\\0';string target=akaRandomName411191;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode target */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minFlips_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minFlips(target);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bulbSwitcher\\\\BulbSwitcher.IV.cpp\\\\Solution\\\\minFlips(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "string getHint(string secret, string guess) {\r         return getHint02(secret, guess);\r         return getHint01(secret, guess);\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bullsAndCows\\bullsAndCows.cpp\\Solution\\getHint(string,string)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     string getHint(string secret, string guess) {\r         return getHint02(secret, guess);\r         return getHint01(secret, guess);\r     }\r \r     string getHint01(string secret, string guess) {\r         int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\r         int total_bulls = 0, total_cows = 0;\r         for(int i = 0; i < secret.size(); i++)\r             appears_in_secret[secret[i] - '0']++;\r         for(int i = 0; i < guess.size(); i++)\r         {\r              if(secret[i] == guess[i])\r                  bulls[secret[i] - '0']++;\r              appears_in_guess[guess[i] - '0']++;\r         }\r         for(int i = 0; i <= 9; i++)\r         {\r             total_bulls += bulls[i];\r             total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\r         }\r         return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\r     }\r \r     // Another implemntation - to save more space\r     string getHint02(string secret, string guess) {\r         \r         const int digital_num = 10;\r         int secret_stat[digital_num]={0};\r         \r         int bull = 0;\r         for(int i=0; i<secret.size(); i++) {\r             //both number & location are matched, count bull\r             if ( secret[i] == guess[i] ) {\r                 bull++;\r                 continue;\r             }\r             //otherwise, count the unmatched digits.\r             secret_stat[secret[i]-'0']++;\r         }\r         \r         int cow = 0;\r         for(int i=0; i<guess.size(); i++) {\r             //deal with duplication - decrease the digits count if cow is found.\r             if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\r                 cow++;\r             }\r         }\r         \r         return to_string(bull) + \"A\" + to_string(cow) + \"B\";\r     }\r };",
    "m": [
      "string getHint02(string secret, string guess) {\r\n        \r\n        const int digital_num = 10;\r\n        int secret_stat[digital_num]={0};\r\n        \r\n        int bull = 0;\r\n        for(int i=0; i<secret.size(); i++) {\r\n            //both number & location are matched, count bull\r\n            if ( secret[i] == guess[i] ) {\r\n                bull++;\r\n                continue;\r\n            }\r\n            //otherwise, count the unmatched digits.\r\n            secret_stat[secret[i]-'0']++;\r\n        }\r\n        \r\n        int cow = 0;\r\n        for(int i=0; i<guess.size(); i++) {\r\n            //deal with duplication - decrease the digits count if cow is found.\r\n            if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\r\n                cow++;\r\n            }\r\n        }\r\n        \r\n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\r\n    }",
      "string getHint01(string secret, string guess) {\r\n        int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\r\n        int total_bulls = 0, total_cows = 0;\r\n        for(int i = 0; i < secret.size(); i++)\r\n            appears_in_secret[secret[i] - '0']++;\r\n        for(int i = 0; i < guess.size(); i++)\r\n        {\r\n             if(secret[i] == guess[i])\r\n                 bulls[secret[i] - '0']++;\r\n             appears_in_guess[guess[i] - '0']++;\r\n        }\r\n        for(int i = 0; i <= 9; i++)\r\n        {\r\n            total_bulls += bulls[i];\r\n            total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\r\n        }\r\n        return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_getHint_string_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_getHint_string_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bullsAndCows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName758779 = new char[2];akaRandomName758779[0] = 97;akaRandomName758779[1] = '\\0';string secret=akaRandomName758779;\nchar* akaRandomName587010 = new char[2];akaRandomName587010[0] = 59;akaRandomName587010[1] = '\\0';string guess=akaRandomName587010;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode secret */\n/* NormalStringDataNode guess */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getHint_string_string_random_0\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getHint(secret,guess);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bullsAndCows\\\\bullsAndCows.cpp\\\\Solution\\\\getHint(string,string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "string getHint01(string secret, string guess) {\r         int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\r         int total_bulls = 0, total_cows = 0;\r         for(int i = 0; i < secret.size(); i++)\r             appears_in_secret[secret[i] - '0']++;\r         for(int i = 0; i < guess.size(); i++)\r         {\r              if(secret[i] == guess[i])\r                  bulls[secret[i] - '0']++;\r              appears_in_guess[guess[i] - '0']++;\r         }\r         for(int i = 0; i <= 9; i++)\r         {\r             total_bulls += bulls[i];\r             total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\r         }\r         return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bullsAndCows\\bullsAndCows.cpp\\Solution\\getHint01(string,string)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     string getHint(string secret, string guess) {\r         return getHint02(secret, guess);\r         return getHint01(secret, guess);\r     }\r \r     string getHint01(string secret, string guess) {\r         int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\r         int total_bulls = 0, total_cows = 0;\r         for(int i = 0; i < secret.size(); i++)\r             appears_in_secret[secret[i] - '0']++;\r         for(int i = 0; i < guess.size(); i++)\r         {\r              if(secret[i] == guess[i])\r                  bulls[secret[i] - '0']++;\r              appears_in_guess[guess[i] - '0']++;\r         }\r         for(int i = 0; i <= 9; i++)\r         {\r             total_bulls += bulls[i];\r             total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\r         }\r         return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\r     }\r \r     // Another implemntation - to save more space\r     string getHint02(string secret, string guess) {\r         \r         const int digital_num = 10;\r         int secret_stat[digital_num]={0};\r         \r         int bull = 0;\r         for(int i=0; i<secret.size(); i++) {\r             //both number & location are matched, count bull\r             if ( secret[i] == guess[i] ) {\r                 bull++;\r                 continue;\r             }\r             //otherwise, count the unmatched digits.\r             secret_stat[secret[i]-'0']++;\r         }\r         \r         int cow = 0;\r         for(int i=0; i<guess.size(); i++) {\r             //deal with duplication - decrease the digits count if cow is found.\r             if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\r                 cow++;\r             }\r         }\r         \r         return to_string(bull) + \"A\" + to_string(cow) + \"B\";\r     }\r };",
    "m": [
      "string getHint(string secret, string guess) {\r\n        return getHint02(secret, guess);\r\n        return getHint01(secret, guess);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_getHint01_string_string_random_1(void) {\n{\nAKA_test_case_name=\"Solution_getHint01_string_string_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bullsAndCows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName362533 = new char[2];akaRandomName362533[0] = -51;akaRandomName362533[1] = '\\0';string secret=akaRandomName362533;\nchar* akaRandomName382375 = new char[2];akaRandomName382375[0] = 68;akaRandomName382375[1] = '\\0';string guess=akaRandomName382375;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode secret */\n/* NormalStringDataNode guess */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getHint01_string_string_random_1\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getHint01(secret,guess);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bullsAndCows\\\\bullsAndCows.cpp\\\\Solution\\\\getHint01(string,string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getHint01_string_string_random_1(void) {\n{\nAKA_test_case_name=\"Solution_getHint01_string_string_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bullsAndCows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName367345 = new char[2];akaRandomName367345[0] = -51;akaRandomName367345[1] = '\\0';string secret=akaRandomName367345;\nchar* akaRandomName691966 = new char[2];akaRandomName691966[0] = 68;akaRandomName691966[1] = '\\0';string guess=akaRandomName691966;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode secret */\n/* NormalStringDataNode guess */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getHint01_string_string_random_1\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getHint01(secret,guess);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bullsAndCows\\\\bullsAndCows.cpp\\\\Solution\\\\getHint01(string,string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "string getHint02(string secret, string guess) {\r         \r         const int digital_num = 10;\r         int secret_stat[digital_num]={0};\r         \r         int bull = 0;\r         for(int i=0; i<secret.size(); i++) {\r             //both number & location are matched, count bull\r             if ( secret[i] == guess[i] ) {\r                 bull++;\r                 continue;\r             }\r             //otherwise, count the unmatched digits.\r             secret_stat[secret[i]-'0']++;\r         }\r         \r         int cow = 0;\r         for(int i=0; i<guess.size(); i++) {\r             //deal with duplication - decrease the digits count if cow is found.\r             if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\r                 cow++;\r             }\r         }\r         \r         return to_string(bull) + \"A\" + to_string(cow) + \"B\";\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\bullsAndCows\\bullsAndCows.cpp\\Solution\\getHint02(string,string)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     string getHint(string secret, string guess) {\r         return getHint02(secret, guess);\r         return getHint01(secret, guess);\r     }\r \r     string getHint01(string secret, string guess) {\r         int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\r         int total_bulls = 0, total_cows = 0;\r         for(int i = 0; i < secret.size(); i++)\r             appears_in_secret[secret[i] - '0']++;\r         for(int i = 0; i < guess.size(); i++)\r         {\r              if(secret[i] == guess[i])\r                  bulls[secret[i] - '0']++;\r              appears_in_guess[guess[i] - '0']++;\r         }\r         for(int i = 0; i <= 9; i++)\r         {\r             total_bulls += bulls[i];\r             total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\r         }\r         return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\r     }\r \r     // Another implemntation - to save more space\r     string getHint02(string secret, string guess) {\r         \r         const int digital_num = 10;\r         int secret_stat[digital_num]={0};\r         \r         int bull = 0;\r         for(int i=0; i<secret.size(); i++) {\r             //both number & location are matched, count bull\r             if ( secret[i] == guess[i] ) {\r                 bull++;\r                 continue;\r             }\r             //otherwise, count the unmatched digits.\r             secret_stat[secret[i]-'0']++;\r         }\r         \r         int cow = 0;\r         for(int i=0; i<guess.size(); i++) {\r             //deal with duplication - decrease the digits count if cow is found.\r             if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\r                 cow++;\r             }\r         }\r         \r         return to_string(bull) + \"A\" + to_string(cow) + \"B\";\r     }\r };",
    "m": [
      "string getHint(string secret, string guess) {\r\n        return getHint02(secret, guess);\r\n        return getHint01(secret, guess);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_getHint02_string_string_random_4(void) {\n{\nAKA_test_case_name=\"Solution_getHint02_string_string_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bullsAndCows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName891433 = new char[2];akaRandomName891433[0] = -124;akaRandomName891433[1] = '\\0';string secret=akaRandomName891433;\nchar* akaRandomName37705 = new char[2];akaRandomName37705[0] = -43;akaRandomName37705[1] = '\\0';string guess=akaRandomName37705;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode secret */\n/* NormalStringDataNode guess */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getHint02_string_string_random_4\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getHint02(secret,guess);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bullsAndCows\\\\bullsAndCows.cpp\\\\Solution\\\\getHint02(string,string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_getHint02_string_string_random_4(void) {\n{\nAKA_test_case_name=\"Solution_getHint02_string_string_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\bullsAndCows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName170433 = new char[2];akaRandomName170433[0] = -124;akaRandomName170433[1] = '\\0';string secret=akaRandomName170433;\nchar* akaRandomName181875 = new char[2];akaRandomName181875[0] = -43;akaRandomName181875[1] = '\\0';string guess=akaRandomName181875;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode secret */\n/* NormalStringDataNode guess */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getHint02_string_string_random_4\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getHint02(secret,guess);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\bullsAndCows\\\\bullsAndCows.cpp\\\\Solution\\\\getHint02(string,string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int maxCoins(vector<int>& nums) {\r         //remove all of zero item\r         nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r         \r         //add 1 for head and tail\r         nums.insert(nums.begin(),1);\r         nums.push_back(1);\r         \r         int n = nums.size();\r         vector< vector<int> > matrix(n, vector<int>(n,0));\r         \r         return maxCoins_DP(nums, matrix);\r         return maxCoins_DC(nums, matrix, 0, n-1);\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\burstBalloons\\BurstBalloons.cpp\\Solution\\maxCoins(vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int maxCoins(vector<int>& nums) {\r         //remove all of zero item\r         nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r         \r         //add 1 for head and tail\r         nums.insert(nums.begin(),1);\r         nums.push_back(1);\r         \r         int n = nums.size();\r         vector< vector<int> > matrix(n, vector<int>(n,0));\r         \r         return maxCoins_DP(nums, matrix);\r         return maxCoins_DC(nums, matrix, 0, n-1);\r     }\r     \r     \r     //Divide and Conquer\r     //\r     //  If we seprate the array to two part, left part and right part.\r     //\r     //  Then, we will find in this problem the left and right become adjacent \r     //  and have effects on the maxCoins in the future.\r     //\r     //  So, if we think reversely, if the balloon i is the last balloon of all to burst, \r     //  the left and right section now has well defined boundary and do not affect each other! \r     //  Therefore we can do either recursive method with memoization\r     //\r     int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r         if (low + 1 == high) return 0;\r         if (matrix[low][high] > 0) return matrix[low][high];\r         int result = 0;\r         for (int i = low + 1; i < high; ++i){\r             result = max(result,  nums[low] * nums[i] * nums[high] \r                                     + maxCoins_DC(nums, matrix, low, i) \r                                     + maxCoins_DC(nums, matrix, i, high));\r         }\r         matrix[low][high] = result;\r         return result;\r     }\r     \r     //Dynamic Programming\r     // \r     //  using the same idea of above \r     //\r     int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r         int n = nums.size();\r         for (int k = 2; k < n; ++k) {\r             for (int low = 0; low < n - k; low++){\r                 int high = low + k;\r                 for (int i = low + 1; i < high; ++i)\r                     dp[low][high] = max( dp[low][high],\r                          nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r             }\r         }\r         return dp[0][n - 1];\r     }\r     \r private:\r     void printVector(vector<int>& nums) {\r         cout << \"nums: \";\r         for (auto n: nums) {\r             cout << n << ' ';\r         }\r         cout << '\\n';\r     }\r };",
    "m": [
      "int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r\n        int n = nums.size();\r\n        for (int k = 2; k < n; ++k) {\r\n            for (int low = 0; low < n - k; low++){\r\n                int high = low + k;\r\n                for (int i = low + 1; i < high; ++i)\r\n                    dp[low][high] = max( dp[low][high],\r\n                         nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r\n            }\r\n        }\r\n        return dp[0][n - 1];\r\n    }",
      "int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r\n        if (low + 1 == high) return 0;\r\n        if (matrix[low][high] > 0) return matrix[low][high];\r\n        int result = 0;\r\n        for (int i = low + 1; i < high; ++i){\r\n            result = max(result,  nums[low] * nums[i] * nums[high] \r\n                                    + maxCoins_DC(nums, matrix, low, i) \r\n                                    + maxCoins_DC(nums, matrix, i, high));\r\n        }\r\n        matrix[low][high] = result;\r\n        return result;\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_maxCoins_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxCoins_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BurstBalloons.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1133977131;\nnums.push_back(nums_element0);\nint nums_element1=-473075688;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxCoins_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxCoins(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\burstBalloons\\\\BurstBalloons.cpp\\\\Solution\\\\maxCoins(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r         if (low + 1 == high) return 0;\r         if (matrix[low][high] > 0) return matrix[low][high];\r         int result = 0;\r         for (int i = low + 1; i < high; ++i){\r             result = max(result,  nums[low] * nums[i] * nums[high] \r                                     + maxCoins_DC(nums, matrix, low, i) \r                                     + maxCoins_DC(nums, matrix, i, high));\r         }\r         matrix[low][high] = result;\r         return result;\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\burstBalloons\\BurstBalloons.cpp\\Solution\\maxCoins_DC(vector<int>&,vector<vector<int>>&,int,int)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int maxCoins(vector<int>& nums) {\r         //remove all of zero item\r         nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r         \r         //add 1 for head and tail\r         nums.insert(nums.begin(),1);\r         nums.push_back(1);\r         \r         int n = nums.size();\r         vector< vector<int> > matrix(n, vector<int>(n,0));\r         \r         return maxCoins_DP(nums, matrix);\r         return maxCoins_DC(nums, matrix, 0, n-1);\r     }\r     \r     \r     //Divide and Conquer\r     //\r     //  If we seprate the array to two part, left part and right part.\r     //\r     //  Then, we will find in this problem the left and right become adjacent \r     //  and have effects on the maxCoins in the future.\r     //\r     //  So, if we think reversely, if the balloon i is the last balloon of all to burst, \r     //  the left and right section now has well defined boundary and do not affect each other! \r     //  Therefore we can do either recursive method with memoization\r     //\r     int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r         if (low + 1 == high) return 0;\r         if (matrix[low][high] > 0) return matrix[low][high];\r         int result = 0;\r         for (int i = low + 1; i < high; ++i){\r             result = max(result,  nums[low] * nums[i] * nums[high] \r                                     + maxCoins_DC(nums, matrix, low, i) \r                                     + maxCoins_DC(nums, matrix, i, high));\r         }\r         matrix[low][high] = result;\r         return result;\r     }\r     \r     //Dynamic Programming\r     // \r     //  using the same idea of above \r     //\r     int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r         int n = nums.size();\r         for (int k = 2; k < n; ++k) {\r             for (int low = 0; low < n - k; low++){\r                 int high = low + k;\r                 for (int i = low + 1; i < high; ++i)\r                     dp[low][high] = max( dp[low][high],\r                          nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r             }\r         }\r         return dp[0][n - 1];\r     }\r     \r private:\r     void printVector(vector<int>& nums) {\r         cout << \"nums: \";\r         for (auto n: nums) {\r             cout << n << ' ';\r         }\r         cout << '\\n';\r     }\r };",
    "m": [
      "int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r\n        if (low + 1 == high) return 0;\r\n        if (matrix[low][high] > 0) return matrix[low][high];\r\n        int result = 0;\r\n        for (int i = low + 1; i < high; ++i){\r\n            result = max(result,  nums[low] * nums[i] * nums[high] \r\n                                    + maxCoins_DC(nums, matrix, low, i) \r\n                                    + maxCoins_DC(nums, matrix, i, high));\r\n        }\r\n        matrix[low][high] = result;\r\n        return result;\r\n    }",
      "int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r\n        if (low + 1 == high) return 0;\r\n        if (matrix[low][high] > 0) return matrix[low][high];\r\n        int result = 0;\r\n        for (int i = low + 1; i < high; ++i){\r\n            result = max(result,  nums[low] * nums[i] * nums[high] \r\n                                    + maxCoins_DC(nums, matrix, low, i) \r\n                                    + maxCoins_DC(nums, matrix, i, high));\r\n        }\r\n        matrix[low][high] = result;\r\n        return result;\r\n    }",
      "int maxCoins(vector<int>& nums) {\r\n        //remove all of zero item\r\n        nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r\n        \r\n        //add 1 for head and tail\r\n        nums.insert(nums.begin(),1);\r\n        nums.push_back(1);\r\n        \r\n        int n = nums.size();\r\n        vector< vector<int> > matrix(n, vector<int>(n,0));\r\n        \r\n        return maxCoins_DP(nums, matrix);\r\n        return maxCoins_DC(nums, matrix, 0, n-1);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_maxCoins_DC_vector_int_vector_vector_int_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxCoins_DC_vector_int_vector_vector_int_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BurstBalloons.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\nvector<vector<int>> matrix;\n\n\nint low=4;\n\n\nint high=6;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-1379363060;\nnums.push_back(nums_element0);\n/* VectorDataNode matrix */\nvector<int> matrix_element0;\nint matrix_element0_element0=-212449938;\nmatrix_element0.push_back(matrix_element0_element0);\nint matrix_element0_element1=1374231302;\nmatrix_element0.push_back(matrix_element0_element1);\nmatrix.push_back(matrix_element0);\n/* NormalNumberDataNode low */\n/* NormalNumberDataNode high */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxCoins_DC_vector_int_vector_vector_int_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxCoins_DC(nums,matrix,low,high);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\burstBalloons\\\\BurstBalloons.cpp\\\\Solution\\\\maxCoins_DC(vector<int>&,vector<vector<int>>&,int,int)\");\n\n\nvector<int> EXPECTED_nums;\n\nvector<vector<int>> EXPECTED_matrix;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r         int n = nums.size();\r         for (int k = 2; k < n; ++k) {\r             for (int low = 0; low < n - k; low++){\r                 int high = low + k;\r                 for (int i = low + 1; i < high; ++i)\r                     dp[low][high] = max( dp[low][high],\r                          nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r             }\r         }\r         return dp[0][n - 1];\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\burstBalloons\\BurstBalloons.cpp\\Solution\\maxCoins_DP(vector<int>&,vector<vector<int>>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int maxCoins(vector<int>& nums) {\r         //remove all of zero item\r         nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r         \r         //add 1 for head and tail\r         nums.insert(nums.begin(),1);\r         nums.push_back(1);\r         \r         int n = nums.size();\r         vector< vector<int> > matrix(n, vector<int>(n,0));\r         \r         return maxCoins_DP(nums, matrix);\r         return maxCoins_DC(nums, matrix, 0, n-1);\r     }\r     \r     \r     //Divide and Conquer\r     //\r     //  If we seprate the array to two part, left part and right part.\r     //\r     //  Then, we will find in this problem the left and right become adjacent \r     //  and have effects on the maxCoins in the future.\r     //\r     //  So, if we think reversely, if the balloon i is the last balloon of all to burst, \r     //  the left and right section now has well defined boundary and do not affect each other! \r     //  Therefore we can do either recursive method with memoization\r     //\r     int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r         if (low + 1 == high) return 0;\r         if (matrix[low][high] > 0) return matrix[low][high];\r         int result = 0;\r         for (int i = low + 1; i < high; ++i){\r             result = max(result,  nums[low] * nums[i] * nums[high] \r                                     + maxCoins_DC(nums, matrix, low, i) \r                                     + maxCoins_DC(nums, matrix, i, high));\r         }\r         matrix[low][high] = result;\r         return result;\r     }\r     \r     //Dynamic Programming\r     // \r     //  using the same idea of above \r     //\r     int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r         int n = nums.size();\r         for (int k = 2; k < n; ++k) {\r             for (int low = 0; low < n - k; low++){\r                 int high = low + k;\r                 for (int i = low + 1; i < high; ++i)\r                     dp[low][high] = max( dp[low][high],\r                          nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r             }\r         }\r         return dp[0][n - 1];\r     }\r     \r private:\r     void printVector(vector<int>& nums) {\r         cout << \"nums: \";\r         for (auto n: nums) {\r             cout << n << ' ';\r         }\r         cout << '\\n';\r     }\r };",
    "m": [
      "int maxCoins(vector<int>& nums) {\r\n        //remove all of zero item\r\n        nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r\n        \r\n        //add 1 for head and tail\r\n        nums.insert(nums.begin(),1);\r\n        nums.push_back(1);\r\n        \r\n        int n = nums.size();\r\n        vector< vector<int> > matrix(n, vector<int>(n,0));\r\n        \r\n        return maxCoins_DP(nums, matrix);\r\n        return maxCoins_DC(nums, matrix, 0, n-1);\r\n    }"
    ],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_maxCoins_DP_vector_int_vector_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxCoins_DP_vector_int_vector_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BurstBalloons.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\nvector<vector<int>> dp;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=32936862;\nnums.push_back(nums_element0);\nint nums_element1=755846789;\nnums.push_back(nums_element1);\n/* VectorDataNode dp */\nvector<int> dp_element0;\nint dp_element0_element0=-1123753453;\ndp_element0.push_back(dp_element0_element0);\nint dp_element0_element1=-489562146;\ndp_element0.push_back(dp_element0_element1);\ndp.push_back(dp_element0);\nvector<int> dp_element1;\nint dp_element1_element0=445740363;\ndp_element1.push_back(dp_element1_element0);\ndp.push_back(dp_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxCoins_DP_vector_int_vector_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxCoins_DP(nums,dp);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\burstBalloons\\\\BurstBalloons.cpp\\\\Solution\\\\maxCoins_DP(vector<int>&,vector<vector<int>>&)\");\n\n\nvector<int> EXPECTED_nums;\n\nvector<vector<int>> EXPECTED_dp;\n\n\n\n// tear down\n;\n}\n}\n",
          "void AKA_TEST_Solution_maxCoins_DP_vector_int_vector_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxCoins_DP_vector_int_vector_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BurstBalloons.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\nvector<vector<int>> dp;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=32936862;\nnums.push_back(nums_element0);\nint nums_element1=755846789;\nnums.push_back(nums_element1);\n/* VectorDataNode dp */\nvector<int> dp_element0;\nint dp_element0_element0=-1123753453;\ndp_element0.push_back(dp_element0_element0);\nint dp_element0_element1=-489562146;\ndp_element0.push_back(dp_element0_element1);\ndp.push_back(dp_element0);\nvector<int> dp_element1;\nint dp_element1_element0=445740363;\ndp_element1.push_back(dp_element1_element0);\ndp.push_back(dp_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxCoins_DP_vector_int_vector_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxCoins_DP(nums,dp);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\burstBalloons\\\\BurstBalloons.cpp\\\\Solution\\\\maxCoins_DP(vector<int>&,vector<vector<int>>&)\");\n\n\nvector<int> EXPECTED_nums;\n\nvector<vector<int>> EXPECTED_dp;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  },
  {
    "fm": "void printVector(vector<int>& nums) {\r         cout << \"nums: \";\r         for (auto n: nums) {\r             cout << n << ' ';\r         }\r         cout << '\\n';\r     }",
    "f": [],
    "path_fm": "C:\\Users\\daidu\\Projects\\SQA-LAB\\AKA\\prj-data\\haoel_leetcode\\algorithms\\cpp\\2\\burstBalloons\\BurstBalloons.cpp\\Solution\\printVector(vector<int>&)",
    "c": [
      ""
    ],
    "fc": "class Solution {\r public:\r     int maxCoins(vector<int>& nums) {\r         //remove all of zero item\r         nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\r         \r         //add 1 for head and tail\r         nums.insert(nums.begin(),1);\r         nums.push_back(1);\r         \r         int n = nums.size();\r         vector< vector<int> > matrix(n, vector<int>(n,0));\r         \r         return maxCoins_DP(nums, matrix);\r         return maxCoins_DC(nums, matrix, 0, n-1);\r     }\r     \r     \r     //Divide and Conquer\r     //\r     //  If we seprate the array to two part, left part and right part.\r     //\r     //  Then, we will find in this problem the left and right become adjacent \r     //  and have effects on the maxCoins in the future.\r     //\r     //  So, if we think reversely, if the balloon i is the last balloon of all to burst, \r     //  the left and right section now has well defined boundary and do not affect each other! \r     //  Therefore we can do either recursive method with memoization\r     //\r     int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\r         if (low + 1 == high) return 0;\r         if (matrix[low][high] > 0) return matrix[low][high];\r         int result = 0;\r         for (int i = low + 1; i < high; ++i){\r             result = max(result,  nums[low] * nums[i] * nums[high] \r                                     + maxCoins_DC(nums, matrix, low, i) \r                                     + maxCoins_DC(nums, matrix, i, high));\r         }\r         matrix[low][high] = result;\r         return result;\r     }\r     \r     //Dynamic Programming\r     // \r     //  using the same idea of above \r     //\r     int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\r         int n = nums.size();\r         for (int k = 2; k < n; ++k) {\r             for (int low = 0; low < n - k; low++){\r                 int high = low + k;\r                 for (int i = low + 1; i < high; ++i)\r                     dp[low][high] = max( dp[low][high],\r                          nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\r             }\r         }\r         return dp[0][n - 1];\r     }\r     \r private:\r     void printVector(vector<int>& nums) {\r         cout << \"nums: \";\r         for (auto n: nums) {\r             cout << n << ' ';\r         }\r         cout << '\\n';\r     }\r };",
    "m": [],
    "datatest": [
      {
        "id": 0,
        "dt": {},
        "td": [
          "void AKA_TEST_Solution_printVector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_printVector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\BurstBalloons.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1252471791;\nnums.push_back(nums_element0);\nint nums_element1=1164247722;\nnums.push_back(nums_element1);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_printVector_vector_int_random_0\");AKA_INSTANCE___Solution->printVector(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\2\\\\burstBalloons\\\\BurstBalloons.cpp\\\\Solution\\\\printVector(vector<int>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n"
        ],
        "simplified_t": [],
        "isAutomated": true
      }
    ]
  }
]