[
    {
        "source": "int compareGroup(Person* a, Person* b, int size_a, int size_b) { if (size_a ! = size_b) return 0; else { for (int i = 0; i < size_a; i++) if (strcmp(a[i].name, b[i].name) ! = 0 || a[i].age ! = b[i].age || a[i].salary ! = b[i].salary) return 0; return 1; } }",
        "target": "Person* a; Person* b; int size_a = 5; int size_b = 896064882; int AKA_ACTUAL_OUTPUT = compareGroup(a, b, size_a, size_b)"
    },
    {
        "source": "long linear_search1(long a[], long n, long find) { long c; for (c = 0; c < n; c++) { if (a[c] =  = find) return c; } return -1; }",
        "target": "long a[2]; long n = 5; long find = -243044902; a[0] = 1555610589; a[1] = -2123849484; long AKA_ACTUAL_OUTPUT = Algorithm::Search::linear_search1(a, n, find)"
    },
    {
        "source": "long linear_search1(long a[], long n, long find) { long c; for (c = 0; c < n; c++) { if (a[c] =  = find) return c; } return -1; }",
        "target": "long a[2]; long n = 5; long find = -243044902; a[0] = 1555610589; a[1] = -2123849484; long AKA_ACTUAL_OUTPUT = Algorithm::Search::linear_search1(a, n, find)"
    },
    {
        "source": "long linear_search2(long *pointer, long n, long find) { long c; for (c = 0; c < n; c++) { if (*(pointer + c) =  = find) return c; } return -1; }",
        "target": "long AKA_ARRAY_INIT_pointer[1]; long AKA_ARRAY_INIT_pointer_0 = 389288122; AKA_ARRAY_INIT_pointer[0] = AKA_ARRAY_INIT_pointer_0; long* pointer = AKA_ARRAY_INIT_pointer; long n = 8; long find = -952697251; long AKA_ACTUAL_OUTPUT = Algorithm::Search::linear_search2(pointer, n, find)"
    },
    {
        "source": "long linear_search2(long *pointer, long n, long find) { long c; for (c = 0; c < n; c++) { if (*(pointer + c) =  = find) return c; } return -1; }",
        "target": "long AKA_ARRAY_INIT_pointer[1]; long AKA_ARRAY_INIT_pointer_0 = 389288122; AKA_ARRAY_INIT_pointer[0] = AKA_ARRAY_INIT_pointer_0; long* pointer = AKA_ARRAY_INIT_pointer; long n = 8; long find = -952697251; long AKA_ACTUAL_OUTPUT = Algorithm::Search::linear_search2(pointer, n, find)"
    },
    {
        "source": "int binarySearch(int arr[], int l, int r, int x) { if (r > = l) { int mid = l + (r - l) / 2; if (arr[mid] =  = x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } return -1; }",
        "target": "int arr[3]; int l = -1131179258; int r = -456405430; int x = 1538791365; arr[0] = 1302875958; arr[1] = 571177432; arr[2] = -1653009281; int AKA_ACTUAL_OUTPUT = Algorithm::Search::binarySearch(arr, l, r, x)"
    },
    {
        "source": "int binarySearch(int arr[], int l, int r, int x) { if (r > = l) { int mid = l + (r - l) / 2; if (arr[mid] =  = x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } return -1; }",
        "target": "int arr[3]; int l = -1131179258; int r = -456405430; int x = 1538791365; arr[0] = 1302875958; arr[1] = 571177432; arr[2] = -1653009281; int AKA_ACTUAL_OUTPUT = Algorithm::Search::binarySearch(arr, l, r, x)"
    },
    {
        "source": "void NaivePatternSearch(char *pat, char *txt) { int M = strlen(pat); int N = strlen(txt); for (int i = 0; i < = N - M; i++) { int j; for (j = 0; j < M; j++) if (txt[i + j] ! = pat[j]) break; if (j =  = M) printf(\"Pattern found at index %d n\", i); } }",
        "target": "char AKA_ARRAY_INIT_pat[2]; char AKA_ARRAY_INIT_pat_0 = -17; AKA_ARRAY_INIT_pat[0] = AKA_ARRAY_INIT_pat_0; char AKA_ARRAY_INIT_pat_1 = 0; AKA_ARRAY_INIT_pat[1] = AKA_ARRAY_INIT_pat_1; char* pat = AKA_ARRAY_INIT_pat; char AKA_ARRAY_INIT_txt[2]; char AKA_ARRAY_INIT_txt_0 = -105; AKA_ARRAY_INIT_txt[0] = AKA_ARRAY_INIT_txt_0; char AKA_ARRAY_INIT_txt_1 = -114; AKA_ARRAY_INIT_txt[1] = AKA_ARRAY_INIT_txt_1; char* txt = AKA_ARRAY_INIT_txt; Algorithm::Search::NaivePatternSearch(pat, txt); } }"
    },
    {
        "source": "void KMPSearch(char *pat, char *txt) { int M = strlen(pat); int N = strlen(txt); int lps[M]; computeLPSArray(pat, M, lps); int i = 0; int j = 0; while (i < N) { if (pat[j] =  = txt[i]) { j++; i++; } if (j =  = M) { printf(\"Found pattern at index %d n\", i - j); j = lps[j - 1]; } else if (i < N && pat[j] ! = txt[i]) { if (j ! = 0) j = lps[j - 1]; else i = i + 1; } } }",
        "target": "char AKA_ARRAY_INIT_pat[2]; char AKA_ARRAY_INIT_pat_0 = 58; AKA_ARRAY_INIT_pat[0] = AKA_ARRAY_INIT_pat_0; char AKA_ARRAY_INIT_pat_1 = 91; AKA_ARRAY_INIT_pat[1] = AKA_ARRAY_INIT_pat_1; char* pat = AKA_ARRAY_INIT_pat; char AKA_ARRAY_INIT_txt[2]; char AKA_ARRAY_INIT_txt_0 = 12; AKA_ARRAY_INIT_txt[0] = AKA_ARRAY_INIT_txt_0; char AKA_ARRAY_INIT_txt_1 = 62; AKA_ARRAY_INIT_txt[1] = AKA_ARRAY_INIT_txt_1; char* txt = AKA_ARRAY_INIT_txt; Algorithm::Search::KMPSearch(pat, txt); } }"
    },
    {
        "source": "int getWidth() { return width; } int width; int height;",
        "target": "AKA_INSTANCE___Polygon = new ::Rectangle(); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Polygon->getWidth()"
    },
    {
        "source": "int getHeight() { return height; } int width; int height;",
        "target": "int AKA_INSTANCE___Polygon_a = 163220920; int AKA_INSTANCE___Polygon_b = -59622500; AKA_INSTANCE___Polygon = new ::Rectangle(AKA_INSTANCE___Polygon_a, AKA_INSTANCE___Polygon_b); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Polygon->getHeight()"
    },
    {
        "source": "virtual int area() { } int width; int height;",
        "target": "int AKA_INSTANCE___Polygon_a = 1250268467; int AKA_INSTANCE___Polygon_b = 239612311; AKA_INSTANCE___Polygon = new ::Rectangle(AKA_INSTANCE___Polygon_a, AKA_INSTANCE___Polygon_b); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Polygon->area()"
    },
    {
        "source": "int area() { return width * height; }",
        "target": "int AKA_INSTANCE___Rectangle_a = -41120190; int AKA_INSTANCE___Rectangle_b = 265018672; AKA_INSTANCE___Rectangle = new ::Rectangle(AKA_INSTANCE___Rectangle_a, AKA_INSTANCE___Rectangle_b); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Rectangle->area()"
    },
    {
        "source": "int area() { return width * height / 2; }",
        "target": "int AKA_INSTANCE___Triangle_a = 1548647601; int AKA_INSTANCE___Triangle_b = 1811647126; AKA_INSTANCE___Triangle = new ::Triangle(AKA_INSTANCE___Triangle_a, AKA_INSTANCE___Triangle_b); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Triangle->area()"
    },
    {
        "source": "int compare(Polygon r1, Polygon r2) { if (r1.getWidth() =  = r2.getWidth()) if (r1.getHeight() =  = r2.getHeight()) return 1; return 0; }",
        "target": "int r1_a = 1027949756; int r1_b = -728550828; ::Rectangle r1 = ::Rectangle(r1_a, r1_b); int r2_a = -354168310; int r2_b = 1051373654; ::Rectangle r2 = ::Rectangle(r2_a, r2_b); int AKA_ACTUAL_OUTPUT = compare(r1, r2)"
    },
    {
        "source": "int compare(Polygon r1[3], Polygon r2[3]) { for (int i = 0; i < 3; i++) if (r1[i].getWidth() ! = r2[i].getWidth() && r1[i].getHeight() ! = r2[i].getHeight()) return 0; return 1; }",
        "target": "Polygon r1[3]; Polygon r2[3]; int r10_a = -786241031; int r10_b = 1409949452; r1[0] = ::Rectangle(r10_a, r10_b); int r11_a = 927541757; int r11_b = -375421258; r1[1] = ::Rectangle(r11_a, r11_b); int r12_a = 239935624; int r12_b = -1014455850; r1[2] = ::Triangle(r12_a, r12_b); int r20_a = -1560718111; int r20_b = -205886120; r2[0] = ::Rectangle(r20_a, r20_b); r2[1] = ::Triangle(); r2[2] = ::Rectangle(); int AKA_ACTUAL_OUTPUT = compare(r1, r2)"
    },
    {
        "source": "int check_array(float a[3]) { int k = 0; for (int i = 0; i < 3; i++) { if (abs(a[i] - sqrt(i + 1)) < 0.000001) { k++; } } return k; }",
        "target": "float a[3]; a[0] = 0.27; a[1] = 0.29; a[2] = 0.31; int AKA_ACTUAL_OUTPUT = check_array(a)"
    },
    {
        "source": "int Tritype(int i, int j, int k) { int trityp = 0; if (i < 0 || j < 0 || k < 0) return 3; if (i + j < = k || j + k < = i || k + i < = j) return 3; if (i =  = j) trityp = trityp + 1; if (i =  = k) trityp = trityp + 1; if (j =  = k) trityp = trityp + 1; if (trityp > = 2) trityp = 2; return trityp; }",
        "target": "int i = 319958939; int j = 1908060676; int k = -744899584; int AKA_ACTUAL_OUTPUT = Tritype(i, j, k)"
    },
    {
        "source": "int Tritype(int i, int j, int k) { int trityp = 0; if (i < 0 || j < 0 || k < 0) return 3; if (i + j < = k || j + k < = i || k + i < = j) return 3; if (i =  = j) trityp = trityp + 1; if (i =  = k) trityp = trityp + 1; if (j =  = k) trityp = trityp + 1; if (trityp > = 2) trityp = 2; return trityp; }",
        "target": "int i = 319958939; int j = 1908060676; int k = -744899584; int AKA_ACTUAL_OUTPUT = Tritype(i, j, k)"
    },
    {
        "source": "int Tritype(int i, int j, int k) { int trityp = 0; if (i < 0 || j < 0 || k < 0) return 3; if (i + j < = k || j + k < = i || k + i < = j) return 3; if (i =  = j) trityp = trityp + 1; if (i =  = k) trityp = trityp + 1; if (j =  = k) trityp = trityp + 1; if (trityp > = 2) trityp = 2; return trityp; }",
        "target": "int i = 319958939; int j = 1908060676; int k = -744899584; int AKA_ACTUAL_OUTPUT = Tritype(i, j, k)"
    },
    {
        "source": "int uninit_var(int a[3], int b[3]) { int i, k = 0; for(i = 0; i<2; i++) { if(a[i] =  = 0) return 0; if(a[i] ! = a[i+1]) k = 0; else if(k =  = 2) return 0; while(b[k] ! = a[i]) if(k =  = 2) return 0; else k++; } return 1; }",
        "target": "int a[3]; int b[3]; a[0] = -1845251358; a[1] = 820619589; a[2] = -1332749930; b[0] = 88253211; b[1] = 2034614304; b[2] = 1518242527; int AKA_ACTUAL_OUTPUT = uninit_var(a, b)"
    },
    {
        "source": "int find_maximum(int a[], int n) { int c, max, index; max = a[0]; index = 0; for (c = 1; c < n; c++) { if (a[c] > max) { index = c; max = a[c]; } } return index; }",
        "target": "int a[2]; int n = 7; a[0] = 1483059593; a[1] = 1237015033; int AKA_ACTUAL_OUTPUT = find_maximum(a, n)"
    },
    {
        "source": "void print (int r) { int c, space; int stars = -1; if (r < = 0) return; space = r - 1; stars + = 2; for (c = 0; c < space; c++) printf(\" \"); for (c = 0; c < stars; c++) printf(\"*\"); printf(\"\\n\"); print(--r); space = r + 1; stars - = 2; for (c = 0; c < space; c++) printf(\" \"); for (c = 0; c < stars; c++) printf(\"*\"); printf(\"\\n\"); }",
        "target": "int r = 5; print(r); } }"
    },
    {
        "source": "long reverse(long n) { static long r = 0; if (n =  = 0) return 0; r = r * 10; r = r + n % 10; reverse(n/10); return r; }",
        "target": "long n = 1258645331; long AKA_ACTUAL_OUTPUT = reverse(n)"
    },
    {
        "source": "int add_digits(int n) { static int sum = 0; if (n =  = 0) { return 0; } sum = n%10 + add_digits(n/10); return sum; }",
        "target": "int n = 1635919859; int AKA_ACTUAL_OUTPUT = add_digits(n)"
    },
    {
        "source": "int check_prime(int a) { int c; for ( c = 2; c < = a - 1; c++ ) { if ( a%c =  = 0 ) return 0; } if ( c =  = a ) return 1; }",
        "target": "int a = 7; int AKA_ACTUAL_OUTPUT = check_prime(a)"
    },
    {
        "source": "int check_prime(int a) { int c; for ( c = 2; c < = a - 1; c++ ) { if ( a%c =  = 0 ) return 0; } if ( c =  = a ) return 1; }",
        "target": "int a = 7; int AKA_ACTUAL_OUTPUT = check_prime(a)"
    },
    {
        "source": "int check_armstrong(long long n) { long long sum = 0, temp; int remainder, digits = 0; temp = n; while (temp ! = 0) { digits++; temp = temp/10; } temp = n; while (temp ! = 0) { remainder = temp%10; sum = sum + power(remainder, digits); temp = temp/10; } if (n =  = sum) return 1; else return 0; }",
        "target": "long long n = 8; int AKA_ACTUAL_OUTPUT = check_armstrong(n)"
    },
    {
        "source": "int check_armstrong(long long n) { long long sum = 0, temp; int remainder, digits = 0; temp = n; while (temp ! = 0) { digits++; temp = temp/10; } temp = n; while (temp ! = 0) { remainder = temp%10; sum = sum + power(remainder, digits); temp = temp/10; } if (n =  = sum) return 1; else return 0; }",
        "target": "long long n = 8; int AKA_ACTUAL_OUTPUT = check_armstrong(n)"
    },
    {
        "source": "int check_vowel(char a) { if ( a > = 'A' && a < = 'Z' ) a = a + 'a' - 'A'; if ( a =  = 'a' || a =  = 'e' || a =  = 'i' || a =  = 'o' || a =  = 'u') return 1; return 0; }",
        "target": "char a = 69; int AKA_ACTUAL_OUTPUT = check_vowel(a)"
    },
    {
        "source": "int check_vowel(char a) { if ( a > = 'A' && a < = 'Z' ) a = a + 'a' - 'A'; if ( a =  = 'a' || a =  = 'e' || a =  = 'i' || a =  = 'o' || a =  = 'u') return 1; return 0; }",
        "target": "char a = 69; int AKA_ACTUAL_OUTPUT = check_vowel(a)"
    },
    {
        "source": "int compare_string(char *first, char *second) { while(*first =  = *second) { if ( *first =  = '\\0' || *second =  = '\\0' ) break; first++; second++; } if( *first =  = '\\0' && *second =  = '\\0' ) return 0; else return -1; }",
        "target": "char AKA_ARRAY_INIT_first[2]; char AKA_ARRAY_INIT_first_0 = 37; AKA_ARRAY_INIT_first[0] = AKA_ARRAY_INIT_first_0; char AKA_ARRAY_INIT_first_1 = 73; AKA_ARRAY_INIT_first[1] = AKA_ARRAY_INIT_first_1; char* first = AKA_ARRAY_INIT_first; char AKA_ARRAY_INIT_second[2]; char AKA_ARRAY_INIT_second_0 = -92; AKA_ARRAY_INIT_second[0] = AKA_ARRAY_INIT_second_0; char AKA_ARRAY_INIT_second_1 = -12; AKA_ARRAY_INIT_second[1] = AKA_ARRAY_INIT_second_1; char* second = AKA_ARRAY_INIT_second; int AKA_ACTUAL_OUTPUT = compare_string(first, second)"
    },
    {
        "source": "int check_subsequence (char a[], char b[]) { int c, d; c = 0; d = 0; while (a[c] ! = '\\0') { while ((a[c] ! = b[d]) && b[d] ! = '\\0') { d++; } if (b[d] =  = '\\0') break; d++; c++; } if (a[c] =  = '\\0') return 1; else return 0; }",
        "target": "char a[1]; char b[1]; a[0] = -42; a[1] = 97; b[0] = -4; b[1] = 68; int AKA_ACTUAL_OUTPUT = check_subsequence(a, b)"
    },
    {
        "source": "int check_anagram(char a[], char b[]) { int first[26], second[26], c = 0; first[20] = 0; second[26] = 0; while (a[c] ! = '\\0') { first[a[c]-'a']++; c++; } c = 0; while (b[c] ! = '\\0') { second[b[c]-'a']++; c++; } for (c = 0; c < 26; c++) { if (first[c] ! = second[c]) return 0; } return 1; }",
        "target": "char a[1]; char b[1]; a[0] = 89; a[1] = -87; b[0] = -45; b[1] = -104; int AKA_ACTUAL_OUTPUT = check_anagram(a, b)"
    },
    {
        "source": "void find_frequency(char s[], int count[]) { int c = 0; while (s[c] ! = '\\0') { if (s[c] > = 'a' && s[c] < = 'z' ) count[s[c]-'a']++; c++; } }",
        "target": "char s[1]; int count[3]; s[0] = 29; s[1] = 65; count[0] = 533692624; count[1] = -1611906770; count[2] = -261894345; find_frequency(s, count); } }"
    },
    {
        "source": "int frequencyDigits(int n, int d) { int c = 0; while (n > 0) { if (n % 10 =  = d) c++; n = n / 10; } return c; }",
        "target": "int n = 3; int d = -670329480; int AKA_ACTUAL_OUTPUT = frequencyDigits(n, d)"
    },
    {
        "source": "int largestNum(int a, int b) { return a * (bool)(a / b) + b * (bool)(b / a); }",
        "target": "int a = -328338691; int b = 801358640; int AKA_ACTUAL_OUTPUT = largestNum(a, b)"
    },
    {
        "source": "int lds(int arr[], int n) { int lds[n]; int i, j, max = 0; for (i = 0; i < n; i++) lds[i] = 1; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i] < arr[j] && lds[i] < lds[j] + 1) lds[i] = lds[j] + 1; for (i = 0; i < n; i++) if (max < lds[i]) max = lds[i]; return max; }",
        "target": "int arr[1]; int n = 10; arr[0] = 1112604843; int AKA_ACTUAL_OUTPUT = lds(arr, n)"
    },
    {
        "source": "int getPriority(char C) { if (C =  = '-' || C =  = '+') return 1; else if (C =  = '*' || C =  = '/') return 2; else if (C =  = '^') return 3; return 0; }",
        "target": "char C = -83; int AKA_ACTUAL_OUTPUT = getPriority(C)"
    },
    {
        "source": "void printDistinctPFs(int n) { long long factorCount[n + 1]; bool prime[n + 1]; for (int i = 0; i < = n; i++) { factorCount[i] = 0; prime[i] = true; } for (int i = 2; i < = n; i++) { if (prime[i] =  = true) { factorCount[i] = 1; for (int j = i * 2; j < = n; j + = i) { factorCount[j]++; prime[j] = false; } } } }",
        "target": "int n = 9; printDistinctPFs(n); } }"
    },
    {
        "source": "int steps(int N, int M) { if (N =  = 1) return 0; else if (N =  = 2) return M; return 2 * M + (N - 3); }",
        "target": "int N = 750372595; int M = 1470340448; int AKA_ACTUAL_OUTPUT = steps(N, M)"
    },
    {
        "source": "void selectionSort(int arr[], int n) { int i, j, min_idx; for (i = 0; i < n - 1; i++) { min_idx = i; for (j = i + 1; j < n; j++) if (arr[j] < arr[min_idx]) min_idx = j; swap(&arr[min_idx], &arr[i]); } }",
        "target": "int arr[3]; int n = 4; arr[0] = 1144247356; arr[1] = 270473347; arr[2] = -563962138; Algorithm::Sort::selectionSort(arr, n); } }"
    },
    {
        "source": "void bubbleSort2(int arr[], int n) { int i, j; bool swapped; for (i = 0; i < n - 1; i++) { swapped = false; for (j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(&arr[j], &arr[j + 1]); swapped = true; } } if (swapped =  = false) break; } }",
        "target": "int arr[2]; int n = 1; arr[0] = -1557408651; arr[1] = -217927943; Algorithm::Sort::bubbleSort2(arr, n); } }"
    },
    {
        "source": "void quickSort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); int x = pi - 1; quickSort(arr, low, x); int y = pi + 1; quickSort(arr, y, high); } }",
        "target": "int arr[1]; int low = -967778146; int high = 526574950; arr[0] = -718352632; Algorithm::Sort::quickSort(arr, low, high); } }"
    },
    {
        "source": "void quickSort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); int x = pi - 1; quickSort(arr, low, x); int y = pi + 1; quickSort(arr, y, high); } }",
        "target": "int arr[1]; int low = -967778146; int high = 526574950; arr[0] = -718352632; Algorithm::Sort::quickSort(arr, low, high); } }"
    },
    {
        "source": "void quickSortIterative(int arr[], int l, int h) { int stack[h - l + 1]; int top = -1; top++; stack[top] = l; top++; stack[top] = h; while (top > = 0) { h = stack[top]; top--; l = stack[top]; top--; int p = partition(arr, l, h); if (p - 1 > l) { top++; stack[top] = l; top++; stack[top] = p - 1; } if (p + 1 < h) { top++; stack[top] = p + 1; top++; stack[top] = h; } } }",
        "target": "int arr[3]; int l = -1436144676; int h = -1520361884; arr[0] = 1351469861; arr[1] = 1516655763; arr[2] = 1935887102; Algorithm::Sort::quickSortIterative(arr, l, h); } }"
    },
    {
        "source": "int* twoSum(int* nums, int numsSize, int target) { int i, min = nums[0], max = nums[0]; or (i = 0; i < numsSize; i++) { if (nums[i] > max) max = nums[i]; if (nums[i] < min) min = nums[i]; } //Ϊm (int*)calloc((max - min + 1), sizeof(int)); int *twosum = (int*)malloc(sizeof(int) * 2); // ÿɨһnumsԪأԪSize; map[nums[i] - min] = ++i) { int lookfornum = target - nums[i]; if (lookfornum<min || lookfornum>max) continue; int dis = lookfornum - min; // жĿǷѾֵ if (map[dis twosum[0] = i; twosum[1] = map[dis] - 1; break; } } return twosum; }",
        "target": "int AKA_ARRAY_INIT_nums[1]; int AKA_ARRAY_INIT_nums_0 = -1348042565; AKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0; int* nums = AKA_ARRAY_INIT_nums; int numsSize = 4; int target = -1666784224; int* AKA_ACTUAL_OUTPUT = twoSum(nums, numsSize, target)"
    },
    {
        "source": "int lengthOfLongestSubstringWithoutContinuousCharacter(char* s) { int i = 1, iMax = 0; while (*(++s) ! = '\\0') { if (*(s - 1) =  = *s) { i = 1; } else { i++; } iMax = iMax < i ? i : iMax; } return iMax; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = -11; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 101; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstringWithoutContinuousCharacter(s)"
    },
    {
        "source": "int lengthOfLongestSubstringWithoutContinuousCharacter(char* s) { int i = 1, iMax = 0; while (*(++s) ! = '\\0') { if (*(s - 1) =  = *s) { i = 1; } else { i++; } iMax = iMax < i ? i : iMax; } return iMax; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = -11; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 101; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstringWithoutContinuousCharacter(s)"
    },
    {
        "source": "int lengthOfLongestSubstring(char* s) { int i = 0, j = 2, max = 0, l = 0; if (s[0] =  = '\\0') return 0; else if ((s[1] =  = '\\0')) return 1; while (1) { f (s[i + 1] ! = '\\0') { j = 1; while (1) { if (s[i + j-1] ! = '\\0') { l = checkRepeat(s, i, j); max = max < l ? l : max; if (l < j) break; j++; } else { break; } } i++; } else { break; } } return max; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 75; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 0; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstring(s)"
    },
    {
        "source": "int lengthOfLongestSubstring(char* s) { int i = 0, j = 2, max = 0, l = 0; if (s[0] =  = '\\0') return 0; else if ((s[1] =  = '\\0')) return 1; while (1) { f (s[i + 1] ! = '\\0') { j = 1; while (1) { if (s[i + j-1] ! = '\\0') { l = checkRepeat(s, i, j); max = max < l ? l : max; if (l < j) break; j++; } else { break; } } i++; } else { break; } } return max; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 75; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 0; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstring(s)"
    },
    {
        "source": "int lengthOfLongestSubstring(char* s) { int i = 0, j = 2, max = 0, l = 0; if (s[0] =  = '\\0') return 0; else if ((s[1] =  = '\\0')) return 1; while (1) { f (s[i + 1] ! = '\\0') { j = 1; while (1) { if (s[i + j-1] ! = '\\0') { l = checkRepeat(s, i, j); max = max < l ? l : max; if (l < j) break; j++; } else { break; } } i++; } else { break; } } return max; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 75; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 0; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstring(s)"
    },
    {
        "source": "int lengthOfLongestSubstring(char* s) { int i = 0, j = 2, max = 0, l = 0; if (s[0] =  = '\\0') return 0; else if ((s[1] =  = '\\0')) return 1; while (1) { f (s[i + 1] ! = '\\0') { j = 1; while (1) { if (s[i + j-1] ! = '\\0') { l = checkRepeat(s, i, j); max = max < l ? l : max; if (l < j) break; j++; } else { break; } } i++; } else { break; } } return max; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 75; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 0; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int AKA_ACTUAL_OUTPUT = lengthOfLongestSubstring(s)"
    },
    {
        "source": "int checkRepeat(char* s, int p, int q) { /صs; int a[200] = { 0 } ; for (i = 0; i < q; i++) { if (a[(int)(s[p + i])]) { break; } else { a[(int)(s[p + i])]++; } } return i; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 123; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 79; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int p = -1267525398; int q = 7; int AKA_ACTUAL_OUTPUT = checkRepeat(s, p, q)"
    },
    {
        "source": "int checkRepeat(char* s, int p, int q) { /صs; int a[200] = { 0 } ; for (i = 0; i < q; i++) { if (a[(int)(s[p + i])]) { break; } else { a[(int)(s[p + i])]++; } } return i; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 123; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 79; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int p = -1267525398; int q = 7; int AKA_ACTUAL_OUTPUT = checkRepeat(s, p, q)"
    },
    {
        "source": "int checkRepeat(char* s, int p, int q) { /صs; int a[200] = { 0 } ; for (i = 0; i < q; i++) { if (a[(int)(s[p + i])]) { break; } else { a[(int)(s[p + i])]++; } } return i; }",
        "target": "char AKA_ARRAY_INIT_s[2]; char AKA_ARRAY_INIT_s_0 = 123; AKA_ARRAY_INIT_s[0] = AKA_ARRAY_INIT_s_0; char AKA_ARRAY_INIT_s_1 = 79; AKA_ARRAY_INIT_s[1] = AKA_ARRAY_INIT_s_1; char* s = AKA_ARRAY_INIT_s; int p = -1267525398; int q = 7; int AKA_ACTUAL_OUTPUT = checkRepeat(s, p, q)"
    },
    {
        "source": "string longestPalindrome(string s) { int n = s.length(); int i = 0; int start; int end; int tmp_len; int max_len = 1; int pos = 0; while (i < n) { start = i; end = i; while (end < n - 1 && s[end + 1] =  = s[end]) { ++end; } i = end + 1; // // (start > 0 && end < n - 1 && s[start - 1] =  = s[end + 1]) { --start; ++end; } tmp_len = end - start + 1; if (tmp_len > max_len) { max_len = tmp_len; pos = start; } } return s.substr(pos, max_len); }",
        "target": "AKA_INSTANCE___Solution2 = new ::Solution2(); char* akaRandomName577826 = new char[2]; akaRandomName577826[0] = 61; akaRandomName577826[1] = '\\0'; string s = akaRandomName577826; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution2->longestPalindrome(s)"
    },
    {
        "source": "string longestPalindrome(string s) { if (s.length() =  = 0) { return \"\"; } int maxlength = 0; string maxString = s.substr(0, 1); for (int i = 0; i < s.length() - 1; i++) { if (i =  = 0) { if (s[0] =  = s[1]) { maxlength = 2; maxString = s.substr(0, 2); } continue; } string str = searchPalindrome(s, i); int length = str.length(); if (length > maxlength) { maxlength = length; maxString = str; } } return maxString; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName981925 = new char[2]; akaRandomName981925[0] = -50; akaRandomName981925[1] = '\\0'; string s = akaRandomName981925; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->longestPalindrome(s)"
    },
    {
        "source": "string searchPalindrome(string s, int start) { int length = 0, maxlength = 0; string str = s.substr(start, 1); if (s[start] =  = s[start + 1]) { maxlength = 2; for (int i = 1; start + i + 1 < s.length() && start - i > = 0; i++) { if (s[start + i + 1] =  = s[start - i]) { maxlength + = 2; } else { break; } } str = s.substr(start - maxlength / 2 + 1, maxlength); } / if (s[start - 1] =  = s[start + 1]) { length = 3; for (int i = 2; start + i < s.length() && start - i > = 0; i++) { if (s[start + i] =  = s[start - i]) { length + = 2; } else { break; } } maxlength = maxlength > length ? maxlength : length; str = s.substr(start - (maxlength - 1) / 2, maxlength); } return str; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName450695 = new char[2]; akaRandomName450695[0] = -45; akaRandomName450695[1] = '\\0'; string s = akaRandomName450695; int start = 1; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->searchPalindrome(s, start)"
    },
    {
        "source": "int reverse1(int x) { int nums[10] = { 0 }, i = 0; long result = 0; for (i = 0; i < 10; i++) { nums[i] = x % 10; x = x / 10; if (x =  = 0) break; } // for (int j = 0; j<i+1; j++) { result = result * 10 + nums[j]; if (result > 2147483647 || result < -2147483647) return 0; } return (int)result; }",
        "target": "int x = -1758245503; int AKA_ACTUAL_OUTPUT = reverse1(x)"
    },
    {
        "source": "int reverse(int x) { int temp = 0, i = 0; long result = 0; for (i = 0; i < 10; i++) { temp = x % 10; result = result * 10 + temp; if (result > 2147483647 || result < -2147483647) return 0; x = x / 10; if (x =  = 0) break; } return (int)result; }",
        "target": "int x = 952034234; int AKA_ACTUAL_OUTPUT = reverse(x)"
    },
    {
        "source": "bool isPalindrome1(int x) { long result = 0; int y = x; if (x < 0) return false; for (int i = 0; i < 10; i++) { result = result * 10 + x % 10; x = x / 10; if (x =  = 0) break; } return result - y =  = 0; }",
        "target": "int x = -1514112893; bool AKA_ACTUAL_OUTPUT = isPalindrome1(x)"
    },
    {
        "source": "bool isPalindrome1(int x) { long result = 0; int y = x; if (x < 0) return false; for (int i = 0; i < 10; i++) { result = result * 10 + x % 10; x = x / 10; if (x =  = 0) break; } return result - y =  = 0; }",
        "target": "int x = -1514112893; bool AKA_ACTUAL_OUTPUT = isPalindrome1(x)"
    },
    {
        "source": "bool isPalindrome(int x) { int result = 0; if (x < 0 || (x % 10 =  = 0 && x ! = 0)) return false; for (int i = 0; i < 10; i++) { result = result * 10 + x % 10; x = x / 10; if (x < = result) break; } return result =  = x || result / 10 =  = x; }",
        "target": "int x = 122726964; bool AKA_ACTUAL_OUTPUT = isPalindrome(x)"
    },
    {
        "source": "bool isPalindrome(int x) { int result = 0; if (x < 0 || (x % 10 =  = 0 && x ! = 0)) return false; for (int i = 0; i < 10; i++) { result = result * 10 + x % 10; x = x / 10; if (x < = result) break; } return result =  = x || result / 10 =  = x; }",
        "target": "int x = 122726964; bool AKA_ACTUAL_OUTPUT = isPalindrome(x)"
    },
    {
        "source": "bool isPalindrome(int x) { int result = 0; if (x < 0 || (x % 10 =  = 0 && x ! = 0)) return false; for (int i = 0; i < 10; i++) { result = result * 10 + x % 10; x = x / 10; if (x < = result) break; } return result =  = x || result / 10 =  = x; }",
        "target": "int x = 122726964; bool AKA_ACTUAL_OUTPUT = isPalindrome(x)"
    },
    {
        "source": "void moveZeroes(int* nums, int numsSize) { int i; int temp; int nonZeroCount = 0; for (i = 0; i<numsSize; i++) { if (nums[i] ! = 0) { nums[nonZeroCount] = nums[i]; nonZeroCount++; } if (nums[i] =  = 0) continue; } for (i = nonZeroCount; i<numsSize; i++) { nums[i] = 0; } }",
        "target": "int AKA_ARRAY_INIT_nums[3]; int AKA_ARRAY_INIT_nums_0 = -299672171; AKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0; int AKA_ARRAY_INIT_nums_1 = 80937251; AKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1; int AKA_ARRAY_INIT_nums_2 = 1809585675; AKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2; int* nums = AKA_ARRAY_INIT_nums; int numsSize = 7; moveZeroes(nums, numsSize); } }"
    },
    {
        "source": "int findMaxLength1(int* nums, int numsSize) { int diff = 0, maxLength = 0; for (int start = 0; start < numsSize; start++) { diff = 0; for (int i = start; i < numsSize; i++) { diff + = (nums[i] =  = 1 ? 1 : -1); if (diff =  = 0) { int length = i - start + 1; maxLength = length > maxLength ? length : maxLength; } } } return maxLength; }",
        "target": "int AKA_ARRAY_INIT_nums[3]; int AKA_ARRAY_INIT_nums_0 = 1724978225; AKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0; int AKA_ARRAY_INIT_nums_1 = 907840714; AKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1; int AKA_ARRAY_INIT_nums_2 = 1710867304; AKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2; int* nums = AKA_ARRAY_INIT_nums; int numsSize = 2; int AKA_ACTUAL_OUTPUT = findMaxLength1(nums, numsSize)"
    },
    {
        "source": "int findMaxLength2(int* nums, int numsSize) { int diff = 0, maxLength = 0; for (int start = 0; start < numsSize; start++) { int iStart = start; if (maxLength) { diff = (nums[start - 1] =  = 0 ? 1 : -1); iStart = start + maxLength - 1; } else { diff = 0; } for (int i = iStart; i < numsSize; i++) { diff + = (nums[i] =  = 1 ? 1 : -1); if (diff =  = 0) { maxLength + = i - iStart + 1; } } } return maxLength; }",
        "target": "int AKA_ARRAY_INIT_nums[2]; int AKA_ARRAY_INIT_nums_0 = -925577948; AKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0; int AKA_ARRAY_INIT_nums_1 = -1012031715; AKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1; int* nums = AKA_ARRAY_INIT_nums; int numsSize = 1; int AKA_ACTUAL_OUTPUT = findMaxLength2(nums, numsSize)"
    },
    {
        "source": "int findMaxLength(int* nums, int numsSize) { int *sumMap = (int*)calloc(2*numsSize+1, sizeof(int)); for(int i = 0; i<2 * numsSize + 1; i++) { sumMap[i] = numsSize + 1; } sumMap[0 + numsSize] = -1; int sum = 0, maxLength = 0; for (int i = 0; i < numsSize; i++) { sum + = (nums[i] =  = 1 ? 1 : -1); if (sumMap[sum + numsSize] =  = numsSize + 1) { sumMap[sum + numsSize] = i; } else { int curLength = i - sumMap[sum + numsSize]; maxLength = maxLength > curLength ? maxLength : curLength; } } return maxLength; }",
        "target": "int AKA_ARRAY_INIT_nums[3]; int AKA_ARRAY_INIT_nums_0 = -1187104485; AKA_ARRAY_INIT_nums[0] = AKA_ARRAY_INIT_nums_0; int AKA_ARRAY_INIT_nums_1 = 1019770646; AKA_ARRAY_INIT_nums[1] = AKA_ARRAY_INIT_nums_1; int AKA_ARRAY_INIT_nums_2 = -1434322140; AKA_ARRAY_INIT_nums[2] = AKA_ARRAY_INIT_nums_2; int* nums = AKA_ARRAY_INIT_nums; int numsSize = 10; int AKA_ACTUAL_OUTPUT = findMaxLength(nums, numsSize)"
    },
    {
        "source": "vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) { if (board[click[0]][click[1]] =  = 'M') { board[click[0]][click[1]] = 'X'; return board; } original_map.assign(board.begin(), board.end()); vector<char> t(board[0].size(), 0); for (int i = 0; i < board.size(); i++) { status_map.push_back(t); } updatestatus_map(); // //p if (status_map[click[0]][click[1]] > 0 ) { original_map[click[0]][click[1]] = status_map[click[0]][click[1]] + 0x30; return original_map; } dfs(click[0], click[1]); return original_map; } vector<vector<char>> original_map; vector<vector<char>> status_map;",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<vector<char>> board; vector<int> click; vector<char> board_element0; char board_element0_element0 = 83; board_element0.push_back(board_element0_element0); board.push_back(board_element0); int click_element0 = 866038439; click.push_back(click_element0); int click_element1 = -1117310019; click.push_back(click_element1); int click_element2 = -1892685060; click.push_back(click_element2); vector<vector<char>> AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->updateBoard(board, click)"
    },
    {
        "source": "void updatestatus_map() { for (int i = 0; i < original_map.size(); i++) { for (int j = 0; j < original_map[i].size(); j++) { if (original_map[i][j] =  = 'M') { setNumsAroundMine(i, j); } } } } vector<vector<char>> original_map; vector<vector<char>> status_map;",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); AKA_INSTANCE___Solution->updatestatus_map(); } }"
    },
    {
        "source": "void setMultiplier(int m) { multiplier = m; } int value; int multiplier;",
        "target": "int AKA_INSTANCE___Calculator_v = -1144447400; int AKA_INSTANCE___Calculator_m = -1285815553; AKA_INSTANCE___Calculator = new ::Calculator(AKA_INSTANCE___Calculator_v, AKA_INSTANCE___Calculator_m); int m = -1993523832; AKA_INSTANCE___Calculator->setMultiplier(m); } }"
    },
    {
        "source": "int getMultiplier() const { return multiplier; } int value; int multiplier;",
        "target": "int AKA_INSTANCE___Calculator_v = 1556925148; int AKA_INSTANCE___Calculator_m = -87128467; AKA_INSTANCE___Calculator = new ::Calculator(AKA_INSTANCE___Calculator_v, AKA_INSTANCE___Calculator_m); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Calculator->getMultiplier()"
    },
    {
        "source": "int add(int x) { return calculateAddition(x); } int value; int multiplier;",
        "target": "int AKA_INSTANCE___Calculator_v = 778447519; int AKA_INSTANCE___Calculator_m = -512512729; AKA_INSTANCE___Calculator = new ::Calculator(AKA_INSTANCE___Calculator_v, AKA_INSTANCE___Calculator_m); int x = 1531976966; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Calculator->add(x)"
    },
    {
        "source": "double divide(int x) { return static_cast<double>(value) / x; } int value; int multiplier;",
        "target": "AKA_INSTANCE___Calculator = new ::Calculator(); int x = 157347228; double AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Calculator->divide(x)"
    },
    {
        "source": "int addAndMultiply(int x) { int sum = add(x); return sum * multiplier; // t value; int multiplier;",
        "target": "AKA_INSTANCE___Calculator = new ::Calculator(); int x = -1715194198; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Calculator->addAndMultiply(x)"
    },
    {
        "source": "int calculateAddition(int x) { return value + x; } int value; int multiplier;",
        "target": "AKA_INSTANCE___Calculator = new ::Calculator(); int x = -304721799; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Calculator->calculateAddition(x)"
    },
    {
        "source": "int testCalculator() { culator calc(10, 2); // Khởi t Kiểm thử hàm add và trả v",
        "target": "int AKA_ACTUAL_OUTPUT = testCalculator()"
    },
    {
        "source": "int brokenCalc(int X, int Y) { if (X > = Y) return X-Y; if ( Y%2 =  = 0 ) return brokenCalc(X, Y/2) + 1; return brokenCalc(X, Y+1) + 1; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int X = 1702818497; int Y = -195975482; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->brokenCalc(X, Y)"
    },
    {
        "source": "void removeBackspaces(string &s) { int i = 0; for(int i = 0; i<s.size(); i++) { if (s[i] =  = '#') { int backSteps = i>0 ? 2 : 1; s.erase(i-backSteps + 1, backSteps); i - = backSteps; } } }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName1787 = new char[2]; akaRandomName1787[0] = -15; akaRandomName1787[1] = '\\0'; string s = akaRandomName1787; AKA_INSTANCE___Solution->removeBackspaces(s); } }"
    },
    {
        "source": "bool backspaceCompare(string S, string T) { removeBackspaces(S); removeBackspaces(T); return S =  = T; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName116023 = new char[2]; akaRandomName116023[0] = 57; akaRandomName116023[1] = '\\0'; string S = akaRandomName116023; char* akaRandomName779212 = new char[2]; akaRandomName779212[0] = 68; akaRandomName779212[1] = '\\0'; string T = akaRandomName779212; bool AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->backspaceCompare(S, T)"
    },
    {
        "source": "int sum1toN(int n) { return n * (n+1) / 2; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = -1062502398; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->sum1toN(n)"
    },
    {
        "source": "int numberOfArithmeticSlices(vector<int>& A) { int result = 0; int len = 0; for (int i = 2; i<A.size(); i++) { if (A[i] - A[i-1] =  = A[i-1] - A[i-2]) { len++; } else { result + = sum1toN(len); len = 0; } } return len =  = 0 ? result : result + sum1toN(len); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> A; int A_element0 = 1829852369; A.push_back(A_element0); int A_element1 = -2083519136; A.push_back(A_element1); int A_element2 = -211435912; A.push_back(A_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->numberOfArithmeticSlices(A)"
    },
    {
        "source": "vector< vector<string> > groupAnagrams(vector<string> &strs) { vector< vector<string> > result; map<string, int> m; for(int i = 0; i<strs.size(); i++) { string word = strs[i]; sort(word.begin(), word.end()); if (m.find(word) =  = m.end()) { vector<string> v; v.push_back(strs[i]); result.push_back(v); m[word] = result.size()-1; } else { result[m[word]].push_back(strs[i]); } } for(int i = 0; i<result.size(); i++) { sort(result[i].begin(), result[i].end()); } return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<string> strs; char* akaRandomName845088 = new char[2]; akaRandomName845088[0] = 125; akaRandomName845088[1] = '\\0'; string strs_element0 = akaRandomName845088; strs.push_back(strs_element0); char* akaRandomName708370 = new char[2]; akaRandomName708370[0] = -19; akaRandomName708370[1] = '\\0'; string strs_element1 = akaRandomName708370; strs.push_back(strs_element1); vector<vector<string>> AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->groupAnagrams(strs)"
    },
    {
        "source": "vector< vector<string> > groupAnagrams(vector<string> &strs) { vector< vector<string> > result; map<string, int> m; for(int i = 0; i<strs.size(); i++) { string word = strs[i]; sort(word.begin(), word.end()); if (m.find(word) =  = m.end()) { vector<string> v; v.push_back(strs[i]); result.push_back(v); m[word] = result.size()-1; } else { result[m[word]].push_back(strs[i]); } } for(int i = 0; i<result.size(); i++) { sort(result[i].begin(), result[i].end()); } return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<string> strs; char* akaRandomName637302 = new char[2]; akaRandomName637302[0] = 125; akaRandomName637302[1] = '\\0'; string strs_element0 = akaRandomName637302; strs.push_back(strs_element0); char* akaRandomName412838 = new char[2]; akaRandomName412838[0] = -19; akaRandomName412838[1] = '\\0'; string strs_element1 = akaRandomName412838; strs.push_back(strs_element1); vector<vector<string>> AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->groupAnagrams(strs)"
    },
    {
        "source": "vector< vector<string> > groupAnagrams01(vector<string> &strs) { vector< vector<string> > result; map<string, multiset<string>> m; for(int i = 0; i<strs.size(); i++) { string word = strs[i]; sort(word.begin(), word.end()); m[word].insert(strs[i]); } for(auto item : m) { vector<string> v(item.second.begin(), item.second.end()); result.push_back(v); } return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<string> strs; char* akaRandomName531566 = new char[2]; akaRandomName531566[0] = 5; akaRandomName531566[1] = '\\0'; string strs_element0 = akaRandomName531566; strs.push_back(strs_element0); char* akaRandomName345274 = new char[2]; akaRandomName345274[0] = 47; akaRandomName345274[1] = '\\0'; string strs_element1 = akaRandomName345274; strs.push_back(strs_element1); char* akaRandomName187003 = new char[2]; akaRandomName187003[0] = 103; akaRandomName187003[1] = '\\0'; string strs_element2 = akaRandomName187003; strs.push_back(strs_element2); vector<vector<string>> AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->groupAnagrams01(strs)"
    },
    {
        "source": "vector<string> anagrams(vector<string> &strs) { vector<string> result; map<string, int> m; for(int i = 0; i<strs.size(); i++) { string word = strs[i]; sort(word.begin(), word.end()); if (m.find(word) =  = m.end()) { m[word] = i; } else { if (m[word]> = 0) { result.push_back(strs[m[word]]); m[word] = -1; } result.push_back(strs[i]); } } return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<string> strs; char* akaRandomName224894 = new char[2]; akaRandomName224894[0] = -25; akaRandomName224894[1] = '\\0'; string strs_element0 = akaRandomName224894; strs.push_back(strs_element0); char* akaRandomName450202 = new char[2]; akaRandomName450202[0] = 64; akaRandomName450202[1] = '\\0'; string strs_element1 = akaRandomName450202; strs.push_back(strs_element1); vector<string> AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->anagrams(strs)"
    },
    {
        "source": "int climbStairs(int n) { if (n< = 3) return n; int a[2] = { 2, 3 } ; for(int i = 4; i< = n; i++) { int t = a[0] + a[1]; a[0] = a[1]; a[1] = t; } return a[1]; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = 9; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->climbStairs(n)"
    },
    {
        "source": "int climbStairs(int n) { if (n< = 3) return n; int a[2] = { 2, 3 } ; for(int i = 4; i< = n; i++) { int t = a[0] + a[1]; a[0] = a[1]; a[1] = t; } return a[1]; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = 9; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->climbStairs(n)"
    },
    {
        "source": "int climbStairs2(int n) { if (n< = 3) return n; return climbStairs(n-1) + climbStairs(n-2); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = 1666997024; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->climbStairs2(n)"
    },
    {
        "source": "int abs_min (int x, int y, int z) { return abs_min(x, abs_min(y, z)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int x = -1137198100; int y = -858464856; int z = 890779558; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->abs_min(x, y, z)"
    },
    {
        "source": "int abs_min(int x, int y) { int ax = abs(x); int ay = abs(y); if (ax =  = ay) return max(x, y); return ax < ay ? x : y; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int x = 651751951; int y = 2072724094; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->abs_min(x, y)"
    },
    {
        "source": "int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) { int min_gap = INT_MAX; for (auto& base : baseCosts) { int gap = closetToppingCost(toppingCosts, target - base, 0); min_gap = abs_min(min_gap, gap); } return target - min_gap; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> baseCosts; vector<int> toppingCosts; int target = -480273005; int baseCosts_element0 = 861523559; baseCosts.push_back(baseCosts_element0); int baseCosts_element1 = -109141621; baseCosts.push_back(baseCosts_element1); int toppingCosts_element0 = -1812648113; toppingCosts.push_back(toppingCosts_element0); int toppingCosts_element1 = -1301327235; toppingCosts.push_back(toppingCosts_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->closestCost(baseCosts, toppingCosts, target)"
    },
    {
        "source": "int closetToppingCost(vector<int>& costs, int target, int idx ) { if (idx > = costs.size()) return target; int select_none = closetToppingCost(costs, target, idx+1); int select_once = closetToppingCost(costs, target - costs[idx], idx+1); int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1); return abs_min(select_none, select_once, select_twice); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> costs; int target = -1295530857; int idx = 1707581507; int costs_element0 = 573464047; costs.push_back(costs_element0); int costs_element1 = 724410652; costs.push_back(costs_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->closetToppingCost(costs, target, idx)"
    },
    {
        "source": "int abs(int n) { return n>0 ? n : -n; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = -379318375; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->abs(n)"
    },
    {
        "source": "void printSet(set<int>& s) { cout << \"[\"; for(auto& n : s) { cout << n << \", \"; } cout << \"]\" << endl; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> s; s.insert(s_element0); int s_element1 = 2062078205; s.insert(s_element1); s.insert(s_element2); AKA_INSTANCE___Solution->printSet(s); set<int> EXPECTED_s; } }"
    },
    {
        "source": "void printSet(set<int>& s) { cout << \"[\"; for(auto& n : s) { cout << n << \", \"; } cout << \"]\" << endl; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> s; s.insert(s_element0); int s_element1 = 2062078205; s.insert(s_element1); s.insert(s_element2); AKA_INSTANCE___Solution->printSet(s); set<int> EXPECTED_s; } }"
    },
    {
        "source": "void printSet(set<int>& s) { cout << \"[\"; for(auto& n : s) { cout << n << \", \"; } cout << \"]\" << endl; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> s; s.insert(s_element0); int s_element1 = 2062078205; s.insert(s_element1); s.insert(s_element2); AKA_INSTANCE___Solution->printSet(s); set<int> EXPECTED_s; } }"
    },
    {
        "source": "void printSet(set<int>& s) { cout << \"[\"; for(auto& n : s) { cout << n << \", \"; } cout << \"]\" << endl; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> s; s.insert(s_element0); int s_element1 = 2062078205; s.insert(s_element1); s.insert(s_element2); AKA_INSTANCE___Solution->printSet(s); set<int> EXPECTED_s; } }"
    },
    {
        "source": "void printSet(set<int>& s) { cout << \"[\"; for(auto& n : s) { cout << n << \", \"; } cout << \"]\" << endl; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> s; s.insert(s_element0); int s_element1 = 2062078205; s.insert(s_element1); s.insert(s_element2); AKA_INSTANCE___Solution->printSet(s); set<int> EXPECTED_s; } }"
    },
    {
        "source": "int findClosetDiff(set<int>& sums, int goal) { auto it = sums.lower_bound(goal); int high = (it =  = sums.end()) ? *(sums.rbegin()) : *it; int low = (it ! = sums.begin()) ? *(--it) : *it; return min(abs(low - goal), abs(high - goal)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> sums; int goal = -599725431; sums.insert(sums_element0); int sums_element1 = 1509715816; sums.insert(sums_element1); sums.insert(sums_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->findClosetDiff(sums, goal)"
    },
    {
        "source": "int findClosetDiff(set<int>& sums, int goal) { auto it = sums.lower_bound(goal); int high = (it =  = sums.end()) ? *(sums.rbegin()) : *it; int low = (it ! = sums.begin()) ? *(--it) : *it; return min(abs(low - goal), abs(high - goal)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> sums; int goal = -599725431; sums.insert(sums_element0); int sums_element1 = 1509715816; sums.insert(sums_element1); sums.insert(sums_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->findClosetDiff(sums, goal)"
    },
    {
        "source": "int findClosetDiff(set<int>& sums, int goal) { auto it = sums.lower_bound(goal); int high = (it =  = sums.end()) ? *(sums.rbegin()) : *it; int low = (it ! = sums.begin()) ? *(--it) : *it; return min(abs(low - goal), abs(high - goal)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> sums; int goal = -599725431; sums.insert(sums_element0); int sums_element1 = 1509715816; sums.insert(sums_element1); sums.insert(sums_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->findClosetDiff(sums, goal)"
    },
    {
        "source": "int findClosetDiff(set<int>& sums, int goal) { auto it = sums.lower_bound(goal); int high = (it =  = sums.end()) ? *(sums.rbegin()) : *it; int low = (it ! = sums.begin()) ? *(--it) : *it; return min(abs(low - goal), abs(high - goal)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> sums; int goal = -599725431; sums.insert(sums_element0); int sums_element1 = 1509715816; sums.insert(sums_element1); sums.insert(sums_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->findClosetDiff(sums, goal)"
    },
    {
        "source": "int findClosetDiff(set<int>& sums, int goal) { auto it = sums.lower_bound(goal); int high = (it =  = sums.end()) ? *(sums.rbegin()) : *it; int low = (it ! = sums.begin()) ? *(--it) : *it; return min(abs(low - goal), abs(high - goal)); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); set<int> sums; int goal = -599725431; sums.insert(sums_element0); int sums_element1 = 1509715816; sums.insert(sums_element1); sums.insert(sums_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->findClosetDiff(sums, goal)"
    },
    {
        "source": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) { if (index > end ) { sums.insert(sum); return; } getAllSums(index+1, end, nums, sum+nums[index], sums); getAllSums(index+1, end, nums, sum, sums); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int index = -1990920058; int end = 1767630601; vector<int> nums; int sum = 2046095734; set<int> sums; int nums_element0 = 285884512; nums.push_back(nums_element0); sums.insert(sums_element0); AKA_INSTANCE___Solution->getAllSums(index, end, nums, sum, sums); vector<int> EXPECTED_nums; set<int> EXPECTED_sums; } }"
    },
    {
        "source": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) { if (index > end ) { sums.insert(sum); return; } getAllSums(index+1, end, nums, sum+nums[index], sums); getAllSums(index+1, end, nums, sum, sums); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int index = -1990920058; int end = 1767630601; vector<int> nums; int sum = 2046095734; set<int> sums; int nums_element0 = 285884512; nums.push_back(nums_element0); sums.insert(sums_element0); AKA_INSTANCE___Solution->getAllSums(index, end, nums, sum, sums); vector<int> EXPECTED_nums; set<int> EXPECTED_sums; } }"
    },
    {
        "source": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) { if (index > end ) { sums.insert(sum); return; } getAllSums(index+1, end, nums, sum+nums[index], sums); getAllSums(index+1, end, nums, sum, sums); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int index = -1990920058; int end = 1767630601; vector<int> nums; int sum = 2046095734; set<int> sums; int nums_element0 = 285884512; nums.push_back(nums_element0); sums.insert(sums_element0); AKA_INSTANCE___Solution->getAllSums(index, end, nums, sum, sums); vector<int> EXPECTED_nums; set<int> EXPECTED_sums; } }"
    },
    {
        "source": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) { if (index > end ) { sums.insert(sum); return; } getAllSums(index+1, end, nums, sum+nums[index], sums); getAllSums(index+1, end, nums, sum, sums); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int index = -1990920058; int end = 1767630601; vector<int> nums; int sum = 2046095734; set<int> sums; int nums_element0 = 285884512; nums.push_back(nums_element0); sums.insert(sums_element0); AKA_INSTANCE___Solution->getAllSums(index, end, nums, sum, sums); vector<int> EXPECTED_nums; set<int> EXPECTED_sums; } }"
    },
    {
        "source": "void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) { if (index > end ) { sums.insert(sum); return; } getAllSums(index+1, end, nums, sum+nums[index], sums); getAllSums(index+1, end, nums, sum, sums); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int index = -1990920058; int end = 1767630601; vector<int> nums; int sum = 2046095734; set<int> sums; int nums_element0 = 285884512; nums.push_back(nums_element0); sums.insert(sums_element0); AKA_INSTANCE___Solution->getAllSums(index, end, nums, sum, sums); vector<int> EXPECTED_nums; set<int> EXPECTED_sums; } }"
    },
    {
        "source": "int minAbsDifference(vector<int>& nums, int goal) { set<int> sums_left, sums_right; int mid = nums.size() / 2; getAllSums(0, mid, nums, sums_left); getAllSums(mid+1, nums.size()-1, nums, sums_right); int minDiff = INT_MAX; for (auto& sum : sums_left) { minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum)); } return minDiff; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; int goal = -44683554; int nums_element0 = 1567627325; nums.push_back(nums_element0); int nums_element1 = -623564934; nums.push_back(nums_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->minAbsDifference(nums, goal)"
    },
    {
        "source": "bool buddyStrings(string A, string B) { if (A.size() ! = B.size()) return false; if (A.size()<2) return false; bool bRepeat = false; bool map[26] = { false } ; int idx[2], diffCnt = 0; for (int i = 0; i<A.size(); i++) { if (map[A[i]-'a']) { bRepeat = true; } map[A[i]-'a'] = true; if ( A[i] ! = B[i] ) { if (diffCnt> = 2) return false; idx[diffCnt++] = i; } } if (diffCnt =  = 0 && bRepeat) return true; return (A[idx[0]] =  = B[idx[1]] && A[idx[1]] =  = B[idx[0]]); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName468129 = new char[2]; akaRandomName468129[0] = -41; akaRandomName468129[1] = '\\0'; string A = akaRandomName468129; char* akaRandomName904269 = new char[2]; akaRandomName904269[0] = 95; akaRandomName904269[1] = '\\0'; string B = akaRandomName904269; bool AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->buddyStrings(A, B)"
    },
    {
        "source": "int total(long h) { return h * (h+1) * (h+2) / 6; }",
        "target": "AKA_INSTANCE___Solution1 = new ::Solution1(); long h = 201542861; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution1->total(h)"
    },
    {
        "source": "int minimumBoxes(int n) { int left = 1, right = pow(6l*n, 1.0/3); while(left < = right) { int mid = left + (right - left) / 2; int t = total(mid); if ( t =  = n ) return mid*(mid+1l)/2; if ( t < n) left = mid + 1; else right = mid - 1; } int height = right; int remind = n - total(height); int bottom = height * (height+1l)/2; left = 1; right = sqrt(2*remind); while ( left < = right) { int mid = left + (right - left)/2; int h = mid*(mid+1)/2; if ( h =  = remind) return bottom + mid; if ( h < remind) left = mid + 1; else right = mid -1; } return bottom + left; }",
        "target": "AKA_INSTANCE___Solution1 = new ::Solution1(); int n = 1067445116; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution1->minimumBoxes(n)"
    },
    {
        "source": "int bulbSwitch(int n) { return (int)sqrt(n); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = -1793982043; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->bulbSwitch(n)"
    },
    {
        "source": "int flipLights(int n, int m) { if (m =  = 0 || n =  = 0) return 1; if (n =  = 1) return 2; if (n =  = 2) return m =  = 1? 3:4; if (m =  = 1) return 4; return m =  = 2 ? 7 :8; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); int n = -28357879; int m = -995990536; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->flipLights(n, m)"
    },
    {
        "source": "int numTimesAllBlue(vector<int>& light) { int n = light.size(); vector<bool> on(n, false); int left = 0; int result = 0; for(int i = 0; i<light.size(); i++) { on[light[i]-1] = true; while (left < n && on[left]) left++; if (left =  = i+1) result++; } return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> light; int light_element0 = -742171133; light.push_back(light_element0); int light_element1 = 198217015; light.push_back(light_element1); int light_element2 = 67053058; light.push_back(light_element2); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->numTimesAllBlue(light)"
    },
    {
        "source": "int minFlips(string target) { int flip = 0; for(auto state : target) { if (state =  = '0' && flip % 2 =  = 1 ) flip++; if (state =  = '1' && flip % 2 =  = 0 ) flip++; } return flip; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName411191 = new char[2]; akaRandomName411191[0] = -91; akaRandomName411191[1] = '\\0'; string target = akaRandomName411191; int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->minFlips(target)"
    },
    {
        "source": "string getHint(string secret, string guess) { return getHint02(secret, guess); return getHint01(secret, guess); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName758779 = new char[2]; akaRandomName758779[0] = 97; akaRandomName758779[1] = '\\0'; string secret = akaRandomName758779; char* akaRandomName587010 = new char[2]; akaRandomName587010[0] = 59; akaRandomName587010[1] = '\\0'; string guess = akaRandomName587010; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->getHint(secret, guess)"
    },
    {
        "source": "string getHint01(string secret, string guess) { int appears_in_secret[10] = { 0 }, appears_in_guess[10] = { 0 }, bulls[10] = { 0 } ; int total_bulls = 0, total_cows = 0; for(int i = 0; i < secret.size(); i++) appears_in_secret[secret[i] - '0']++; for(int i = 0; i < guess.size(); i++) { if(secret[i] =  = guess[i]) bulls[secret[i] - '0']++; appears_in_guess[guess[i] - '0']++; } for(int i = 0; i < = 9; i++) { total_bulls + = bulls[i]; total_cows + = min(appears_in_secret[i], appears_in_guess[i]) - bulls[i]; } return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\"; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName362533 = new char[2]; akaRandomName362533[0] = -51; akaRandomName362533[1] = '\\0'; string secret = akaRandomName362533; char* akaRandomName382375 = new char[2]; akaRandomName382375[0] = 68; akaRandomName382375[1] = '\\0'; string guess = akaRandomName382375; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->getHint01(secret, guess)"
    },
    {
        "source": "string getHint01(string secret, string guess) { int appears_in_secret[10] = { 0 }, appears_in_guess[10] = { 0 }, bulls[10] = { 0 } ; int total_bulls = 0, total_cows = 0; for(int i = 0; i < secret.size(); i++) appears_in_secret[secret[i] - '0']++; for(int i = 0; i < guess.size(); i++) { if(secret[i] =  = guess[i]) bulls[secret[i] - '0']++; appears_in_guess[guess[i] - '0']++; } for(int i = 0; i < = 9; i++) { total_bulls + = bulls[i]; total_cows + = min(appears_in_secret[i], appears_in_guess[i]) - bulls[i]; } return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\"; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName367345 = new char[2]; akaRandomName367345[0] = -51; akaRandomName367345[1] = '\\0'; string secret = akaRandomName367345; char* akaRandomName691966 = new char[2]; akaRandomName691966[0] = 68; akaRandomName691966[1] = '\\0'; string guess = akaRandomName691966; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->getHint01(secret, guess)"
    },
    {
        "source": "string getHint02(string secret, string guess) { const int digital_num = 10; int secret_stat[digital_num] = { 0 } ; int bull = 0; for(int i = 0; i<secret.size(); i++) { if ( secret[i] =  = guess[i] ) { bull++; continue; } secret_stat[secret[i]-'0']++; } int cow = 0; for(int i = 0; i<guess.size(); i++) { if ( secret[i] ! = guess[i] && secret_stat[guess[i]-'0']-- > 0 ) { cow++; } } return to_string(bull) + \"A\" + to_string(cow) + \"B\"; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName891433 = new char[2]; akaRandomName891433[0] = -124; akaRandomName891433[1] = '\\0'; string secret = akaRandomName891433; char* akaRandomName37705 = new char[2]; akaRandomName37705[0] = -43; akaRandomName37705[1] = '\\0'; string guess = akaRandomName37705; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->getHint02(secret, guess)"
    },
    {
        "source": "string getHint02(string secret, string guess) { const int digital_num = 10; int secret_stat[digital_num] = { 0 } ; int bull = 0; for(int i = 0; i<secret.size(); i++) { if ( secret[i] =  = guess[i] ) { bull++; continue; } secret_stat[secret[i]-'0']++; } int cow = 0; for(int i = 0; i<guess.size(); i++) { if ( secret[i] ! = guess[i] && secret_stat[guess[i]-'0']-- > 0 ) { cow++; } } return to_string(bull) + \"A\" + to_string(cow) + \"B\"; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); char* akaRandomName170433 = new char[2]; akaRandomName170433[0] = -124; akaRandomName170433[1] = '\\0'; string secret = akaRandomName170433; char* akaRandomName181875 = new char[2]; akaRandomName181875[0] = -43; akaRandomName181875[1] = '\\0'; string guess = akaRandomName181875; string AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->getHint02(secret, guess)"
    },
    {
        "source": "int maxCoins(vector<int>& nums) { nums.erase(remove_if(nums.begin(), nums.end(), [](int n) { return n =  = 0; } ), nums.end()); nums.insert(nums.begin(), 1); nums.push_back(1); int n = nums.size(); vector< vector<int> > matrix(n, vector<int>(n, 0)); return maxCoins_DP(nums, matrix); return maxCoins_DC(nums, matrix, 0, n-1); }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; int nums_element0 = 1133977131; nums.push_back(nums_element0); int nums_element1 = -473075688; nums.push_back(nums_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->maxCoins(nums)"
    },
    {
        "source": "int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) { if (low + 1 =  = high) return 0; if (matrix[low][high] > 0) return matrix[low][high]; int result = 0; for (int i = low + 1; i < high; ++i) { result = max(result, nums[low] * nums[i] * nums[high] + maxCoins_DC(nums, matrix, low, i) + maxCoins_DC(nums, matrix, i, high)); } matrix[low][high] = result; return result; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; vector<vector<int>> matrix; int low = 4; int high = 6; int nums_element0 = -1379363060; nums.push_back(nums_element0); vector<int> matrix_element0; int matrix_element0_element0 = -212449938; matrix_element0.push_back(matrix_element0_element0); int matrix_element0_element1 = 1374231302; matrix_element0.push_back(matrix_element0_element1); matrix.push_back(matrix_element0); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->maxCoins_DC(nums, matrix, low, high)"
    },
    {
        "source": "int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) { int n = nums.size(); for (int k = 2; k < n; ++k) { for (int low = 0; low < n - k; low++) { int high = low + k; for (int i = low + 1; i < high; ++i) dp[low][high] = max( dp[low][high], nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]); } } return dp[0][n - 1]; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; vector<vector<int>> dp; int nums_element0 = 32936862; nums.push_back(nums_element0); int nums_element1 = 755846789; nums.push_back(nums_element1); vector<int> dp_element0; int dp_element0_element0 = -1123753453; dp_element0.push_back(dp_element0_element0); int dp_element0_element1 = -489562146; dp_element0.push_back(dp_element0_element1); dp.push_back(dp_element0); vector<int> dp_element1; int dp_element1_element0 = 445740363; dp_element1.push_back(dp_element1_element0); dp.push_back(dp_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->maxCoins_DP(nums, dp)"
    },
    {
        "source": "int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) { int n = nums.size(); for (int k = 2; k < n; ++k) { for (int low = 0; low < n - k; low++) { int high = low + k; for (int i = low + 1; i < high; ++i) dp[low][high] = max( dp[low][high], nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]); } } return dp[0][n - 1]; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; vector<vector<int>> dp; int nums_element0 = 32936862; nums.push_back(nums_element0); int nums_element1 = 755846789; nums.push_back(nums_element1); vector<int> dp_element0; int dp_element0_element0 = -1123753453; dp_element0.push_back(dp_element0_element0); int dp_element0_element1 = -489562146; dp_element0.push_back(dp_element0_element1); dp.push_back(dp_element0); vector<int> dp_element1; int dp_element1_element0 = 445740363; dp_element1.push_back(dp_element1_element0); dp.push_back(dp_element1); int AKA_ACTUAL_OUTPUT = AKA_INSTANCE___Solution->maxCoins_DP(nums, dp)"
    },
    {
        "source": "void printVector(vector<int>& nums) { cout << \"nums: \"; for (auto n: nums) { cout << n << ' '; } cout << '\\n'; }",
        "target": "AKA_INSTANCE___Solution = new ::Solution(); vector<int> nums; int nums_element0 = 1252471791; nums.push_back(nums_element0); int nums_element1 = 1164247722; nums.push_back(nums_element1); AKA_INSTANCE___Solution->printVector(nums); vector<int> EXPECTED_nums; } }"
    }
]