[
  {   "m" : [ "void selectionSort(int arr[], int n) {\r\n\tint i, j, min_idx;\r\n\r\n\t// One by one move boundary of unsorted subarray\r\n\tfor (i = 0; i < n - 1; i++) {\r\n\t\t// Find the minimum element in unsorted array\r\n\t\tmin_idx = i;\r\n\t\tfor (j = i + 1; j < n; j++)\r\n\t\t\tif (arr[j] < arr[min_idx])\r\n\t\t\t\tmin_idx = j;\r\n\r\n\t\t// Swap the found minimum element with the first element\r\n\t\tswap(&arr[min_idx], &arr[i]);\r\n\t}\r\n}", "void bubbleSort1(int arr[], int n) {\r\n\tint i, j;\r\n\tfor (i = 0; i < n - 1; i++)\r\n\r\n\t\t// Last i elements are already in place\r\n\t\tfor (j = 0; j < n - i - 1; j++)\r\n\t\t\tif (arr[j] > arr[j + 1])\r\n\t\t\t\tswap(&arr[j], &arr[j + 1]);\r\n}", "void bubbleSort2(int arr[], int n) {\r\n\tint i, j;\r\n\tbool swapped;\r\n\tfor (i = 0; i < n - 1; i++) {\r\n\t\tswapped = false;\r\n\t\tfor (j = 0; j < n - i - 1; j++) {\r\n\t\t\tif (arr[j] > arr[j + 1]) {\r\n\t\t\t\tswap(&arr[j], &arr[j + 1]);\r\n\t\t\t\tswapped = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IF no two elements were swapped by inner loop, then break\r\n\t\tif (swapped == false)\r\n\t\t\tbreak;\r\n\t}\r\n}", "int partition(int arr[], int low, int high) {\r\n\tint pivot = arr[high];    // pivot\r\n\tint i = (low - 1);  // Index of smaller element\r\n\r\n\tfor (int j = low; j <= high - 1; j++) {\r\n\t\t// If current element is smaller than or\r\n\t\t// equal to pivot\r\n\t\tif (arr[j] <= pivot) {\r\n\t\t\ti++;    // increment index of smaller element\r\n\t\t\tswap(&arr[i], &arr[j]);\r\n\t\t}\r\n\t}\r\n\tswap(&arr[i + 1], &arr[high]);\r\n\treturn (i + 1);\r\n}" ],   "fm" : "void swap(int *xp, int *yp) {\r \tint temp = *xp;\r \t*xp = *yp;\r \t*yp = temp;\r }",   "t" : [ "void AKA_TEST_swap_intmul_intmul_random_2(void) {\n{\nAKA_test_case_name=\"swap_intmul_intmul_random_2\";\n\n// set up\n;\n\nint AKA_ARRAY_INIT_xp[2];\n\n\nint AKA_ARRAY_INIT_xp_0=1941229057;\nAKA_ARRAY_INIT_xp[0] = AKA_ARRAY_INIT_xp_0;\n\n\nint AKA_ARRAY_INIT_xp_1=-1493216544;\nAKA_ARRAY_INIT_xp[1] = AKA_ARRAY_INIT_xp_1;\n\nint* xp = AKA_ARRAY_INIT_xp;\nint AKA_ARRAY_INIT_yp[3];\n\n\nint AKA_ARRAY_INIT_yp_0=928581031;\nAKA_ARRAY_INIT_yp[0] = AKA_ARRAY_INIT_yp_0;\n\n\nint AKA_ARRAY_INIT_yp_1=1129332382;\nAKA_ARRAY_INIT_yp[1] = AKA_ARRAY_INIT_yp_1;\n\n\nint AKA_ARRAY_INIT_yp_2=-855793599;\nAKA_ARRAY_INIT_yp[2] = AKA_ARRAY_INIT_yp_2;\n\nint* yp = AKA_ARRAY_INIT_yp;\n\n/* RootDataNode STATIC */\n/* PointerNumberDataNode xp */\n/* PointerNumberDataNode yp */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test swap_intmul_intmul_random_2\");Algorithm::Sort::swap(xp,yp);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\swap(int*,int*)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\swap(int*,int*)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "void swap(int *xp, int *yp) {\r\n\tint temp = *xp;\r\n\t*xp = *yp;\r\n\t*yp = temp;\r\n}" ],   "fm" : "void selectionSort(int arr[], int n) {\r \tint i, j, min_idx;\r \r \t// One by one move boundary of unsorted subarray\r \tfor (i = 0; i < n - 1; i++) {\r \t\t// Find the minimum element in unsorted array\r \t\tmin_idx = i;\r \t\tfor (j = i + 1; j < n; j++)\r \t\t\tif (arr[j] < arr[min_idx])\r \t\t\t\tmin_idx = j;\r \r \t\t// Swap the found minimum element with the first element\r \t\tswap(&arr[min_idx], &arr[i]);\r \t}\r }",   "t" : [ "void AKA_TEST_selectionSort_int_int_random_2(void) {\n{\nAKA_test_case_name=\"selectionSort_int_int_random_2\";\n\n// set up\n;\n\nint arr[3];;\n\n\nint n=4;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=1144247356;\n/* NormalNumberDataNode arr[1] */\narr[1]=270473347;\n/* NormalNumberDataNode arr[2] */\narr[2]=-563962138;\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test selectionSort_int_int_random_2\");Algorithm::Sort::selectionSort(arr,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\selectionSort(int[],int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\selectionSort(int[],int)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "void swap(int *xp, int *yp) {\r\n\tint temp = *xp;\r\n\t*xp = *yp;\r\n\t*yp = temp;\r\n}" ],   "fm" : "void bubbleSort2(int arr[], int n) {\r \tint i, j;\r \tbool swapped;\r \tfor (i = 0; i < n - 1; i++) {\r \t\tswapped = false;\r \t\tfor (j = 0; j < n - i - 1; j++) {\r \t\t\tif (arr[j] > arr[j + 1]) {\r \t\t\t\tswap(&arr[j], &arr[j + 1]);\r \t\t\t\tswapped = true;\r \t\t\t}\r \t\t}\r \r \t\t// IF no two elements were swapped by inner loop, then break\r \t\tif (swapped == false)\r \t\t\tbreak;\r \t}\r }",   "t" : [ "void AKA_TEST_bubbleSort2_int_int_random_2(void) {\n{\nAKA_test_case_name=\"bubbleSort2_int_int_random_2\";\n\n// set up\n;\n\nint arr[2];;\n\n\nint n=1;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=-1557408651;\n/* NormalNumberDataNode arr[1] */\narr[1]=-217927943;\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test bubbleSort2_int_int_random_2\");Algorithm::Sort::bubbleSort2(arr,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\bubbleSort2(int[],int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\bubbleSort2(int[],int)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "int partition(int arr[], int low, int high) {\r\n\tint pivot = arr[high];    // pivot\r\n\tint i = (low - 1);  // Index of smaller element\r\n\r\n\tfor (int j = low; j <= high - 1; j++) {\r\n\t\t// If current element is smaller than or\r\n\t\t// equal to pivot\r\n\t\tif (arr[j] <= pivot) {\r\n\t\t\ti++;    // increment index of smaller element\r\n\t\t\tswap(&arr[i], &arr[j]);\r\n\t\t}\r\n\t}\r\n\tswap(&arr[i + 1], &arr[high]);\r\n\treturn (i + 1);\r\n}", "void quickSort(int arr[], int low, int high) {\r\n\tif (low < high) {\r\n\t\t/* pi is partitioning index, arr[p] is now\r\n\t\t at right place */\r\n\t\tint pi = partition(arr, low, high);\r\n\r\n\t\t// Separately sort elements before\r\n\t\t// partition and after partition\r\n\t\tint x = pi - 1;\r\n\t\tquickSort(arr, low, x);\r\n\t\t\r\n\t\tint y = pi + 1;\r\n\t\tquickSort(arr, y, high);\r\n\t}\r\n}", "void quickSort(int arr[], int low, int high) {\r\n\tif (low < high) {\r\n\t\t/* pi is partitioning index, arr[p] is now\r\n\t\t at right place */\r\n\t\tint pi = partition(arr, low, high);\r\n\r\n\t\t// Separately sort elements before\r\n\t\t// partition and after partition\r\n\t\tint x = pi - 1;\r\n\t\tquickSort(arr, low, x);\r\n\t\t\r\n\t\tint y = pi + 1;\r\n\t\tquickSort(arr, y, high);\r\n\t}\r\n}" ],   "fm" : "void quickSort(int arr[], int low, int high) {\r \tif (low < high) {\r \t\t/* pi is partitioning index, arr[p] is now\r \t\t at right place */\r \t\tint pi = partition(arr, low, high);\r \r \t\t// Separately sort elements before\r \t\t// partition and after partition\r \t\tint x = pi - 1;\r \t\tquickSort(arr, low, x);\r \t\t\r \t\tint y = pi + 1;\r \t\tquickSort(arr, y, high);\r \t}\r }",   "t" : [ "void AKA_TEST_quickSort_int_int_int_random_3(void) {\n{\nAKA_test_case_name=\"quickSort_int_int_int_random_3\";\n\n// set up\n;\n\nint arr[1];;\n\n\nint low=-967778146;\n\n\nint high=526574950;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=-718352632;\n/* NormalNumberDataNode low */\n/* NormalNumberDataNode high */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test quickSort_int_int_int_random_3\");Algorithm::Sort::quickSort(arr,low,high);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\quickSort(int[],int,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n", "void AKA_TEST_quickSort_int_int_int_random_3(void) {\n{\nAKA_test_case_name=\"quickSort_int_int_int_random_3\";\n\n// set up\n;\n\nint arr[1];;\n\n\nint low=-967778146;\n\n\nint high=526574950;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=-718352632;\n/* NormalNumberDataNode low */\n/* NormalNumberDataNode high */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test quickSort_int_int_int_random_3\");Algorithm::Sort::quickSort(arr,low,high);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\quickSort(int[],int,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\quickSort(int[],int,int)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "int partition(int arr[], int low, int high) {\r\n\tint pivot = arr[high];    // pivot\r\n\tint i = (low - 1);  // Index of smaller element\r\n\r\n\tfor (int j = low; j <= high - 1; j++) {\r\n\t\t// If current element is smaller than or\r\n\t\t// equal to pivot\r\n\t\tif (arr[j] <= pivot) {\r\n\t\t\ti++;    // increment index of smaller element\r\n\t\t\tswap(&arr[i], &arr[j]);\r\n\t\t}\r\n\t}\r\n\tswap(&arr[i + 1], &arr[high]);\r\n\treturn (i + 1);\r\n}" ],   "fm" : "void quickSortIterative(int arr[], int l, int h) {\r \t// Create an auxiliary stack\r \tint stack[h - l + 1];\r \r \t// initialize top of stack\r \tint top = -1;\r \r \t// push initial values of l and h to stack\r \ttop++;\r \tstack[top] = l;\r \ttop++;\r \tstack[top] = h;\r \r \t// Keep popping from stack while is not empty\r \twhile (top >= 0) {\r \t\t// Pop h and l\r \t\th = stack[top];\r \t\ttop--;\r \t\tl = stack[top];\r \t\ttop--;\r \r \t\t// Set pivot element at its correct position\r \t\t// in sorted array\r \t\tint p = partition(arr, l, h);\r \r \t\t// If there are elements on left side of pivot,\r \t\t// then push left side to stack\r \t\tif (p - 1 > l) {\r \t\t\ttop++;\r \t\t\tstack[top] = l;\r \t\t\ttop++;\r \t\t\tstack[top] = p - 1;\r \t\t}\r \r \t\t// If there are elements on right side of pivot,\r \t\t// then push right side to stack\r \t\tif (p + 1 < h) {\r \t\t\ttop++;\r \t\t\tstack[top] = p + 1;\r \t\t\ttop++;\r \t\t\tstack[top] = h;\r \t\t}\r \t}\r }",   "t" : [ "void AKA_TEST_quickSortIterative_int_int_int_random_4(void) {\n{\nAKA_test_case_name=\"quickSortIterative_int_int_int_random_4\";\n\n// set up\n;\n\nint arr[3];;\n\n\nint l=-1436144676;\n\n\nint h=-1520361884;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode arr */\n/* NormalNumberDataNode arr[0] */\narr[0]=1351469861;\n/* NormalNumberDataNode arr[1] */\narr[1]=1516655763;\n/* NormalNumberDataNode arr[2] */\narr[2]=1935887102;\n/* NormalNumberDataNode l */\n/* NormalNumberDataNode h */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test quickSortIterative_int_int_int_random_4\");Algorithm::Sort::quickSortIterative(arr,l,h);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\quickSortIterative(int[],int,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\quickSortIterative(int[],int,int)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ ],   "fm" : "void push(struct Node** head_ref, int new_data) {\r \t/* allocate node */\r \tstruct Node* new_node = new Node;\r \r \t/* put in the data  */\r \tnew_node->data = new_data;\r \r \t/* link the old list off the new node */\r \tnew_node->next = (*head_ref);\r \r \t/* move the head to point to the new node */\r \t(*head_ref) = new_node;\r }",   "t" : [ "void AKA_TEST_push_struct_Nodemulmul_int_random_1(void) {\n{\nAKA_test_case_name=\"push_struct_Nodemulmul_int_random_1\";\n\n// set up\n;\n\nstd::vector<struct Node**> AKA_VECTOR_INIT_head_ref;\nstd::vector<struct Node*> AKA_VECTOR_INIT_AKA_VECTOR_INIT_head_ref_0;\n\n\n/* SubStructDataNode AKA_VECTOR_INIT_head_ref_0_0 */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\push(struct Node**,int)\\\\head_ref\\\\AKA_VECTOR_INIT_head_ref_0\\\\AKA_VECTOR_INIT_head_ref_0_0\\\\AKA_VECTOR_INIT_head_ref_0_0\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_ref_0_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_ref_0_0).next;\n\nAKA_VECTOR_INIT_AKA_VECTOR_INIT_head_ref_0.push_back(AKA_VECTOR_INIT_head_ref_0_0);\n\nauto AKA_VECTOR_INIT_head_ref_0 = &(AKA_VECTOR_INIT_AKA_VECTOR_INIT_head_ref_0[0]);\nAKA_VECTOR_INIT_head_ref.push_back(AKA_VECTOR_INIT_head_ref_0);\n\nstruct Node** head_ref = AKA_VECTOR_INIT_head_ref[0];\n\n\nint new_data=-1638272449;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head_ref */\n/* NormalNumberDataNode new_data */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test push_struct_Nodemulmul_int_random_1\");Algorithm::Sort::push(head_ref,new_data);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\push(struct Node**,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\push(struct Node**,int)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ ],   "fm" : "void printList(struct Node *node) {\r \twhile (node != NULL) {\r \t\tprintf(\"%d  \", node->data);\r \t\tnode = node->next;\r \t}\r \tprintf(\"\\n\");\r }",   "t" : [ "void AKA_TEST_printList_struct_Nodemul_random_3(void) {\n{\nAKA_test_case_name=\"printList_struct_Nodemul_random_3\";\n\n// set up\n;\n\nstd::vector<struct Node*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_0).data=-1775759866;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_node_0).next;\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_1).data=-1620435686;\n/* PointerStructureDataNode next */\nstd::vector<struct Node*> AKA_VECTOR_INIT_node_1_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\next\\\\next[0]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_next_0 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_1_DOT_next_0).data=1619895485;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_node_1_DOT_next_0).next;\nAKA_VECTOR_INIT_node_1_DOT_next.push_back(AKA_VECTOR_INIT_node_1_DOT_next_0);\n(*AKA_VECTOR_INIT_node_1).next = AKA_VECTOR_INIT_node_1_DOT_next[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_1);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_2).data=-2007494595;\n/* PointerStructureDataNode next */\nstd::vector<struct Node*> AKA_VECTOR_INIT_node_2_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\next\\\\next[0]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_next_0 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_2_DOT_next_0).data=339174975;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_node_2_DOT_next_0).next;\nAKA_VECTOR_INIT_node_2_DOT_next.push_back(AKA_VECTOR_INIT_node_2_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\next\\\\next[1]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_next_1 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_2_DOT_next_1).data=-1666876839;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_node_2_DOT_next_1).next;\nAKA_VECTOR_INIT_node_2_DOT_next.push_back(AKA_VECTOR_INIT_node_2_DOT_next_1);\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\printList(struct Node*)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\next\\\\next[2]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_next_2 = new ::Node();\n/* NormalNumberDataNode data */\n(*AKA_VECTOR_INIT_node_2_DOT_next_2).data=771429036;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_node_2_DOT_next_2).next;\nAKA_VECTOR_INIT_node_2_DOT_next.push_back(AKA_VECTOR_INIT_node_2_DOT_next_2);\n(*AKA_VECTOR_INIT_node_2).next = AKA_VECTOR_INIT_node_2_DOT_next[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_2);\n\nstruct Node* node = AKA_VECTOR_INIT_node[0];\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test printList_struct_Nodemul_random_3\");Algorithm::Sort::printList(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\printList(struct Node*)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\printList(struct Node*)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "struct Node *quickSortRecur(struct Node *head, struct Node *end) {\r\n\t// base condition\r\n\tif (!head || head == end)\r\n\t\treturn head;\r\n\r\n\tNode *newHead = NULL, *newEnd = NULL;\r\n\r\n\t// Partition the list, newHead and newEnd will be updated\r\n\t// by the partition function\r\n\tstruct Node *pivot = partition(head, end, &newHead, &newEnd);\r\n\r\n\t// If pivot is the smallest element - no need to recur for\r\n\t// the left part.\r\n\tif (newHead != pivot) {\r\n\t\t// Set the node before the pivot node as NULL\r\n\t\tstruct Node *tmp = newHead;\r\n\t\twhile (tmp->next != pivot)\r\n\t\t\ttmp = tmp->next;\r\n\t\ttmp->next = NULL;\r\n\r\n\t\t// Recur for the list before pivot\r\n\t\tnewHead = quickSortRecur(newHead, tmp);\r\n\r\n\t\t// Change next of last node of the left half to pivot\r\n\t\ttmp = getTail(newHead);\r\n\t\ttmp->next = pivot;\r\n\t}\r\n\r\n\t// Recur for the list after the pivot element\r\n\tpivot->next = quickSortRecur(pivot->next, newEnd);\r\n\r\n\treturn newHead;\r\n}", "void quickSort(struct Node **headRef) {\r\n\t(*headRef) = quickSortRecur(*headRef, getTail(*headRef));\r\n\treturn;\r\n}" ],   "fm" : "struct Node *getTail(struct Node *cur) {\r \twhile (cur != NULL && cur->next != NULL)\r \t\tcur = cur->next;\r \treturn cur;\r }",   "t" : [ "void AKA_TEST_getTail_struct_Nodemul_random_3(void) {\n{\nAKA_test_case_name=\"getTail_struct_Nodemul_random_3\";\n\n// set up\n;\n\nstd::vector<struct Node*> AKA_VECTOR_INIT_cur;\n\n\n/* SubStructDataNode cur */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\getTail(struct Node*)\\\\cur\\\\AKA_VECTOR_INIT_cur_0\\\\cur\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_cur_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<struct Node*> AKA_VECTOR_INIT_cur_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\getTail(struct Node*)\\\\cur\\\\AKA_VECTOR_INIT_cur_0\\\\cur\\\\next\\\\next[0]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_cur_0_DOT_next_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_cur_0_DOT_next_0).next;\nAKA_VECTOR_INIT_cur_0_DOT_next.push_back(AKA_VECTOR_INIT_cur_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\getTail(struct Node*)\\\\cur\\\\AKA_VECTOR_INIT_cur_0\\\\cur\\\\next\\\\next[1]\\\\next\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_cur_0_DOT_next_1 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_cur_0_DOT_next_1).next;\nAKA_VECTOR_INIT_cur_0_DOT_next.push_back(AKA_VECTOR_INIT_cur_0_DOT_next_1);\n(*AKA_VECTOR_INIT_cur_0).next = AKA_VECTOR_INIT_cur_0_DOT_next[0];\n\nAKA_VECTOR_INIT_cur.push_back(AKA_VECTOR_INIT_cur_0);\n\n\n/* SubStructDataNode cur */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\getTail(struct Node*)\\\\cur\\\\AKA_VECTOR_INIT_cur_1\\\\cur\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_cur_1 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_cur_1).next;\n\nAKA_VECTOR_INIT_cur.push_back(AKA_VECTOR_INIT_cur_1);\n\n\n/* SubStructDataNode cur */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\getTail(struct Node*)\\\\cur\\\\AKA_VECTOR_INIT_cur_2\\\\cur\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_cur_2 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_cur_2).next;\n\nAKA_VECTOR_INIT_cur.push_back(AKA_VECTOR_INIT_cur_2);\n\nstruct Node* cur = AKA_VECTOR_INIT_cur[0];\nstruct Node* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode cur */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test getTail_struct_Nodemul_random_3\");struct Node* AKA_ACTUAL_OUTPUT=Algorithm::Sort::getTail(cur);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\getTail(struct Node*)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\getTail(struct Node*)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "struct Node *quickSortRecur(struct Node *head, struct Node *end) {\r\n\t// base condition\r\n\tif (!head || head == end)\r\n\t\treturn head;\r\n\r\n\tNode *newHead = NULL, *newEnd = NULL;\r\n\r\n\t// Partition the list, newHead and newEnd will be updated\r\n\t// by the partition function\r\n\tstruct Node *pivot = partition(head, end, &newHead, &newEnd);\r\n\r\n\t// If pivot is the smallest element - no need to recur for\r\n\t// the left part.\r\n\tif (newHead != pivot) {\r\n\t\t// Set the node before the pivot node as NULL\r\n\t\tstruct Node *tmp = newHead;\r\n\t\twhile (tmp->next != pivot)\r\n\t\t\ttmp = tmp->next;\r\n\t\ttmp->next = NULL;\r\n\r\n\t\t// Recur for the list before pivot\r\n\t\tnewHead = quickSortRecur(newHead, tmp);\r\n\r\n\t\t// Change next of last node of the left half to pivot\r\n\t\ttmp = getTail(newHead);\r\n\t\ttmp->next = pivot;\r\n\t}\r\n\r\n\t// Recur for the list after the pivot element\r\n\tpivot->next = quickSortRecur(pivot->next, newEnd);\r\n\r\n\treturn newHead;\r\n}" ],   "fm" : "struct Node *partition(struct Node *head, struct Node *end,\r \t\tstruct Node **newHead, struct Node **newEnd) {\r \tstruct Node *pivot = end;\r \tstruct Node *prev = NULL, *cur = head, *tail = pivot;\r \r \t// During partition, both the head and end of the list might change\r \t// which is updated in the newHead and newEnd variables\r \twhile (cur != pivot) {\r \t\tif (cur->data < pivot->data) {\r \t\t\t// First node that has a value less than the pivot - becomes\r \t\t\t// the new head\r \t\t\tif ((*newHead) == NULL)\r \t\t\t\t(*newHead) = cur;\r \r \t\t\tprev = cur;\r \t\t\tcur = cur->next;\r \t\t} else { // If cur node is greater than pivot\r \t\t\t// Move cur node to next of tail, and change tail\r \t\t\tif (prev)\r \t\t\t\tprev->next = cur->next;\r \t\t\tstruct Node *tmp = cur->next;\r \t\t\tcur->next = NULL;\r \t\t\ttail->next = cur;\r \t\t\ttail = cur;\r \t\t\tcur = tmp;\r \t\t}\r \t}\r \r \t// If the pivot data is the smallest element in the current list,\r \t// pivot becomes the head\r \tif ((*newHead) == NULL)\r \t\t(*newHead) = pivot;\r \r \t// Update newEnd to the current last node\r \t(*newEnd) = tail;\r \r \t// Return the pivot node\r \treturn pivot;\r }",   "t" : [ "void AKA_TEST_partition_struct_Nodemul_struct_Nodemul_struct_Nodemulmul_struct_Nodemulmul_random_0(void) {\n{\nAKA_test_case_name=\"partition_struct_Nodemul_struct_Nodemul_struct_Nodemulmul_struct_Nodemulmul_random_0\";\n\n// set up\n;\n\nstd::vector<struct Node*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\partition(struct Node*,struct Node*,struct Node**,struct Node**)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nstruct Node* head = AKA_VECTOR_INIT_head[0];\nstd::vector<struct Node*> AKA_VECTOR_INIT_end;\n\n\n/* SubStructDataNode end */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\partition(struct Node*,struct Node*,struct Node**,struct Node**)\\\\end\\\\AKA_VECTOR_INIT_end_0\\\\end\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_end_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_end_0).next;\n\nAKA_VECTOR_INIT_end.push_back(AKA_VECTOR_INIT_end_0);\n\n\n/* SubStructDataNode end */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\partition(struct Node*,struct Node*,struct Node**,struct Node**)\\\\end\\\\AKA_VECTOR_INIT_end_1\\\\end\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_end_1 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_end_1).next;\n\nAKA_VECTOR_INIT_end.push_back(AKA_VECTOR_INIT_end_1);\n\nstruct Node* end = AKA_VECTOR_INIT_end[0];\nstruct Node** newHead;\nstruct Node** newEnd;\nstruct Node* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode end */\n/* PointerStructureDataNode newHead */\n/* PointerStructureDataNode newEnd */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test partition_struct_Nodemul_struct_Nodemul_struct_Nodemulmul_struct_Nodemulmul_random_0\");struct Node* AKA_ACTUAL_OUTPUT=Algorithm::Sort::partition(head,end,newHead,newEnd);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\partition(struct Node*,struct Node*,struct Node**,struct Node**)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\partition(struct Node*,struct Node*,struct Node**,struct Node**)",   "c" : [ ],   "fc" : "" },
  {   "m" : [ "struct Node *partition(struct Node *head, struct Node *end,\r\n\t\tstruct Node **newHead, struct Node **newEnd) {\r\n\tstruct Node *pivot = end;\r\n\tstruct Node *prev = NULL, *cur = head, *tail = pivot;\r\n\r\n\t// During partition, both the head and end of the list might change\r\n\t// which is updated in the newHead and newEnd variables\r\n\twhile (cur != pivot) {\r\n\t\tif (cur->data < pivot->data) {\r\n\t\t\t// First node that has a value less than the pivot - becomes\r\n\t\t\t// the new head\r\n\t\t\tif ((*newHead) == NULL)\r\n\t\t\t\t(*newHead) = cur;\r\n\r\n\t\t\tprev = cur;\r\n\t\t\tcur = cur->next;\r\n\t\t} else { // If cur node is greater than pivot\r\n\t\t\t// Move cur node to next of tail, and change tail\r\n\t\t\tif (prev)\r\n\t\t\t\tprev->next = cur->next;\r\n\t\t\tstruct Node *tmp = cur->next;\r\n\t\t\tcur->next = NULL;\r\n\t\t\ttail->next = cur;\r\n\t\t\ttail = cur;\r\n\t\t\tcur = tmp;\r\n\t\t}\r\n\t}\r\n\r\n\t// If the pivot data is the smallest element in the current list,\r\n\t// pivot becomes the head\r\n\tif ((*newHead) == NULL)\r\n\t\t(*newHead) = pivot;\r\n\r\n\t// Update newEnd to the current last node\r\n\t(*newEnd) = tail;\r\n\r\n\t// Return the pivot node\r\n\treturn pivot;\r\n}", "struct Node *quickSortRecur(struct Node *head, struct Node *end) {\r\n\t// base condition\r\n\tif (!head || head == end)\r\n\t\treturn head;\r\n\r\n\tNode *newHead = NULL, *newEnd = NULL;\r\n\r\n\t// Partition the list, newHead and newEnd will be updated\r\n\t// by the partition function\r\n\tstruct Node *pivot = partition(head, end, &newHead, &newEnd);\r\n\r\n\t// If pivot is the smallest element - no need to recur for\r\n\t// the left part.\r\n\tif (newHead != pivot) {\r\n\t\t// Set the node before the pivot node as NULL\r\n\t\tstruct Node *tmp = newHead;\r\n\t\twhile (tmp->next != pivot)\r\n\t\t\ttmp = tmp->next;\r\n\t\ttmp->next = NULL;\r\n\r\n\t\t// Recur for the list before pivot\r\n\t\tnewHead = quickSortRecur(newHead, tmp);\r\n\r\n\t\t// Change next of last node of the left half to pivot\r\n\t\ttmp = getTail(newHead);\r\n\t\ttmp->next = pivot;\r\n\t}\r\n\r\n\t// Recur for the list after the pivot element\r\n\tpivot->next = quickSortRecur(pivot->next, newEnd);\r\n\r\n\treturn newHead;\r\n}", "struct Node *quickSortRecur(struct Node *head, struct Node *end) {\r\n\t// base condition\r\n\tif (!head || head == end)\r\n\t\treturn head;\r\n\r\n\tNode *newHead = NULL, *newEnd = NULL;\r\n\r\n\t// Partition the list, newHead and newEnd will be updated\r\n\t// by the partition function\r\n\tstruct Node *pivot = partition(head, end, &newHead, &newEnd);\r\n\r\n\t// If pivot is the smallest element - no need to recur for\r\n\t// the left part.\r\n\tif (newHead != pivot) {\r\n\t\t// Set the node before the pivot node as NULL\r\n\t\tstruct Node *tmp = newHead;\r\n\t\twhile (tmp->next != pivot)\r\n\t\t\ttmp = tmp->next;\r\n\t\ttmp->next = NULL;\r\n\r\n\t\t// Recur for the list before pivot\r\n\t\tnewHead = quickSortRecur(newHead, tmp);\r\n\r\n\t\t// Change next of last node of the left half to pivot\r\n\t\ttmp = getTail(newHead);\r\n\t\ttmp->next = pivot;\r\n\t}\r\n\r\n\t// Recur for the list after the pivot element\r\n\tpivot->next = quickSortRecur(pivot->next, newEnd);\r\n\r\n\treturn newHead;\r\n}", "struct Node *getTail(struct Node *cur) {\r\n\twhile (cur != NULL && cur->next != NULL)\r\n\t\tcur = cur->next;\r\n\treturn cur;\r\n}", "void quickSort(struct Node **headRef) {\r\n\t(*headRef) = quickSortRecur(*headRef, getTail(*headRef));\r\n\treturn;\r\n}" ],   "fm" : "struct Node *quickSortRecur(struct Node *head, struct Node *end) {\r \t// base condition\r \tif (!head || head == end)\r \t\treturn head;\r \r \tNode *newHead = NULL, *newEnd = NULL;\r \r \t// Partition the list, newHead and newEnd will be updated\r \t// by the partition function\r \tstruct Node *pivot = partition(head, end, &newHead, &newEnd);\r \r \t// If pivot is the smallest element - no need to recur for\r \t// the left part.\r \tif (newHead != pivot) {\r \t\t// Set the node before the pivot node as NULL\r \t\tstruct Node *tmp = newHead;\r \t\twhile (tmp->next != pivot)\r \t\t\ttmp = tmp->next;\r \t\ttmp->next = NULL;\r \r \t\t// Recur for the list before pivot\r \t\tnewHead = quickSortRecur(newHead, tmp);\r \r \t\t// Change next of last node of the left half to pivot\r \t\ttmp = getTail(newHead);\r \t\ttmp->next = pivot;\r \t}\r \r \t// Recur for the list after the pivot element\r \tpivot->next = quickSortRecur(pivot->next, newEnd);\r \r \treturn newHead;\r }",   "t" : [ "void AKA_TEST_quickSortRecur_struct_Nodemul_struct_Nodemul_random_4(void) {\n{\nAKA_test_case_name=\"quickSortRecur_struct_Nodemul_struct_Nodemul_random_4\";\n\n// set up\n;\nAlgorithm::Sort::quickSortRecur;\n\nstd::vector<struct Node*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\quickSortRecur(struct Node*,struct Node*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\quickSortRecur(struct Node*,struct Node*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode Node() */\nAKA_mark(\"Calling: \\\\Node()|ROOT\\\\Sort.cpp\\\\quickSortRecur(struct Node*,struct Node*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\Node()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::Node();\n/* NormalNumberDataNode data */\n/* data : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nstruct Node* head = AKA_VECTOR_INIT_head[0];\nstruct Node* end;\nstruct Node* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode end */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test quickSortRecur_struct_Nodemul_struct_Nodemul_random_4\");struct Node* AKA_ACTUAL_OUTPUT=Algorithm::Sort::quickSortRecur(head,end);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\Algorithm\\\\Sort.cpp\\\\Algorithm\\\\Sort\\\\quickSortRecur(struct Node*,struct Node*)\");\n\n\n\n\n// tear down\n;\n}\n}\n" ],   "f" : [ ],   "path_fm" : "C:\\Users\\admin\\akautauto\\datatest\\duc-anh\\Algorithm\\Sort.cpp\\Algorithm\\Sort\\quickSortRecur(struct Node*,struct Node*)",   "c" : [ ],   "fc" : "" }
]
